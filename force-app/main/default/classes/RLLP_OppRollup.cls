/*
    Copyright (c) 2011, Salesforce.org
    All rights reserved.

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Salesforce.org nor the names of
      its contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
    FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
    COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
    INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
    BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
    LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
    ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
    POSSIBILITY OF SUCH DAMAGE.
*/
/**
* @author Salesforce.org
* @date 2011 (2.0)
* @group Rollups
* @group-content ../../ApexDocContent/Rollups.htm
* @description Main logic class for rollups of opportunities to the Accounts, Contacts, and Households.
*/
public without sharing class RLLP_OppRollup {
    @TestVisible
    private Boolean isCustomizableRollupsEnabled {
        get {
            if (isCustomizableRollupsEnabled == null) {
                isCustomizableRollupsEnabled = RLLP_OppRollup_UTIL.customizableRollupEngineEnabled;
            }

            return isCustomizableRollupsEnabled;
        }
        set;
    }

    /** @description Constructor gets settings and sets up variables. */
    public RLLP_OppRollup(){
        // setup households settings
        RLLP_OppRollup_UTIL.setupRollupVars(UTIL_CustomSettingsFacade.getHouseholdsSettings());
        // setup user rollups
        RLLP_OppRollup_UTIL.setupUserRollupVars();
    }

    /*******************************************************************************************************
    * @description Opportunity rollups from triggers: determines which opportunities have changed and pass
    * the contact, account, and household IDs to rollup methods.
    * @param newOpps The map of Id to Opportunity from trigger new.
    * @param listOld The map of Id to Opportunity from trigger old.
    * @return void This method does updates directly and returns nothing.
    ********************************************************************************************************/
    public void rollupForOppTrigger( map<id, Opportunity> newOpps, map<id, Opportunity> oldOpps ) {
        //opp ids for contact/hh querying
        set<id> contactRequerySet = new set<id>();
        //opp ids for Account querying
        set<id> accountRequerySet = new set<id>();

            //delete or insert
            if (newOpps == null || oldOpps == null){
                for (id oid : (newOpps == null ? oldOpps.keySet() : newOpps.keySet())){
                    Opportunity o = (newOpps == null ? oldOpps.get(oid) : newOpps.get(oid));
                    if (RLLP_OppRollup_UTIL.oppForRollup(o)){
                        if (RLLP_OppRollup_UTIL.needsAccountRollup(o)){
                            accountRequerySet.add(o.AccountId);
                        }
                        if (RLLP_OppRollup_UTIL.needsContactRollup(o)){
                            contactRequerySet.add(oid);
                        }
                    }
                }
            }
            //update
            else{
                for (id oid : newOpps.keySet()){
                   Opportunity newo = newOpps.get(oid);
                   Opportunity oldo = oldOpps.get(oid);
                   //if the new one is valid and there are differences between the two opps
                   if (RLLP_OppRollup_UTIL.oppForRollup(newo, oldo)){
                        if (RLLP_OppRollup_UTIL.needsAccountRollup(newo)){
                            accountRequerySet.add(newo.AccountId);
                        }
                        if (RLLP_OppRollup_UTIL.needsContactRollup(newo)){
                            contactRequerySet.add(oid);
                        }
                   }
                }
            }

        if (!accountRequerySet.isEmpty()){
            RLLP_OppRollup_UTIL oppRollupUtil = new RLLP_OppRollup_UTIL();
            map<id, Account> amap = new map<id, account>((list<Account>)Database.query(oppRollupUtil.buildAccountQuery() +
                                                                        ' where id in :accountRequerySet'));
            //if we only need to rollup a single Account, do sync
            if (amap.size() == 1 || system.isFuture() || system.isBatch()){
                rollupAccounts(amap);
            }
            //do it @future
            else if (Limits.getAsyncCalls() < Limits.getLimitAsyncCalls()){
                rollupAccountsFuture(amap.keySet());
            }
        }

        //contacts needs to be done async to make sure the OCR is in place
        if (!contactRequerySet.isEmpty()){
            if (system.isFuture() || system.isBatch())
                RLLP_OppRollup.rollupContactsandHouseholdsForTrigger(contactRequerySet);
            else
                RLLP_OppRollup.rollupContactsandHouseholdsForTriggerFuture(contactRequerySet);
        }
    }

    /*******************************************************************************************************
    * @description Future wrapper method for updating contacts and households from a set of opportunity IDs.
    * @param OppIds A set of opportunity ids.
    * @return void This method does updates directly and returns nothing.
    ********************************************************************************************************/
    @future
    public static void rollupContactsandHouseholdsForTriggerFuture(set<id> OppIds) {
        rollupContactsandHouseholdsForTrigger(OppIds);
    }

    /*******************************************************************************************************
    * @description Updating contacts and households rollups from a set of opportunity IDs.
    * @param oppIds A set of opportunity ids.
    * @return void This method does updates directly and returns nothing.
    ********************************************************************************************************/
    public static void rollupContactsandHouseholdsForTrigger(Set<Id> oppIds){
        //we need this to make sure there's a proper OCR when Contact Opps are inserted
        // use the contact roles to find the contacts and households
        String query = new RLLP_OppRollup_UTIL().buildOpportunityContactRoleQuery() +
            ' WHERE Opportunity.Id IN :oppIds and IsPrimary = true ALL ROWS ';
        Map<Id, Contact> contactById = new Map<Id, Contact>();
        Map<Id, npo02__Household__c> householdById = new Map<Id, npo02__Household__c>();


        for (OpportunityContactRole role : Database.query(query)){
            contactById.put(role.ContactId, role.Contact);

            if (role.Contact.npo02__Household__c != null) {
                householdById.put(role.Contact.npo02__Household__c, role.Contact.npo02__Household__r);
            }

        }

        if (contactById.isEmpty()) {
            return;
        }

        RLLP_OppRollup oppRollup = new RLLP_OppRollup();
        oppRollup.rollupContacts(contactById);

        // NOTE: Household here refers to the household object which require legacy rollups only.
        if (!householdById.isEmpty()) {
            oppRollup.rollupHouseholds(householdById);
        }
    }

    /**
     * @description Calls the appropriate rollup engine (legacy or crlp) for the account ids provided
     * @param accountIds Ids for the accounts that require rollups to be recalculated
     */
    public void rollupAccounts(Set<Id> accountIds) {
        if (accountIds == null || accountIds.isEmpty()) {
            return;
        }

        if (isCustomizableRollupsEnabled) {
            runCustomizableRollups(accountIds);
            return;
        }

        if (shouldRunImmediate(accountIds)) {
            rollupAccounts(getAccountById(accountIds));

        } else {
            RLLP_OppRollup.rollupAccountsFuture(accountIds);
        }
    }

    /**
     * @description Calls the appropriate rollup engine (legacy or crlp) for the contact ids provided
     * @param contactIds Ids for the contacts that require rollups to be recalculated
     */
    public void rollupContacts(Set<Id> contactIds) {
        if (contactIds == null || contactIds.isEmpty()) {
            return;
        }

        if (isCustomizableRollupsEnabled) {
            runCustomizableRollups(contactIds);
            return;
        }

        if (shouldRunImmediate(contactIds)) {
            rollupContacts(getContactById(contactIds));

        } else {
            RLLP_OppRollup.rollupContactsFuture(contactIds);
        }
    }

    /**
     * @description Calls the future or immediate customizable rollups depending on current context
     * @param  ids The ids of the sObjects that require rollups to be recalculated
     */
    private void runCustomizableRollups(Set<Id> ids){
        if (shouldRunImmediate(ids)) {
            CRLP_RollupQueueable.runRollupsForIds(new List<Id>(ids));

        } else {
            System.enqueueJob(new CRLP_RollupQueueable(new List<Id>(ids)));
        }
    }

    /**
     * @description Determines if the context is already async or if there is only 1 record to update
     * @param ids The set of ids that need their rollups refreshed
     * @return Boolean - true when the rollups should happen immediately
     */
    private Boolean shouldRunImmediate(Set<Id> ids) {
        return ids.size() == 1 || System.isFuture() || System.isBatch() || System.isQueueable();
    }

    /**
     * @description Returns the map of contacts with the fields required for processing the rollups
     * @param contactIds The set of contact ids that require their rollups to be updated
     * @return Map<Id, Contact> the map of contacts by their ids
     */
    private static Map<Id, Account> getAccountById(Set<Id> accountIds) {
        if (accountIds == null || accountIds.isEmpty()) {
            return new Map<Id, Account>();
        }

        String query = new RLLP_OppRollup_UTIL().buildAccountQuery() + ' WHERE Id IN :accountIds';

        return new Map<Id, Account>((List<Account>)Database.query(query));
    }

    /**
     * @description Returns the map of contacts with the fields required for processing the rollups
     * @param contactIds The set of contact ids that require their rollups to be updated
     * @return Map<Id, Contact> the map of contacts by their ids
     */
    @TestVisible
    private static Map<Id, Contact> getContactById(Set<Id> contactIds) {
        if (contactIds == null || contactIds.isEmpty()) {
            return new Map<Id, Contact>();
        }

        String query = new RLLP_OppRollup_UTIL().buildContactQuery() + ' WHERE Id IN :contactIds';

        return new Map<Id, Contact>((List<Contact>)Database.query(query));
    }

    /*******************************************************************************************************
    * @description Future wrapper method for updating account rollups from a set of account IDs.
    * @param accountIds A set of account ids.
    * @return void This method does updates directly and returns nothing.
    ********************************************************************************************************/
    @future
    public static void rollupAccountsFuture(Set<Id> accountIds) {
        new RLLP_OppRollup().rollupAccounts(getAccountById(accountIds));
    }

    /*******************************************************************************************************
    * @description Future wrapper method for updating contact rollups from a set of contact IDs.
    * @param contactIds A set of contact ids.
    * @return void This method does updates directly and returns nothing.
    ********************************************************************************************************/
    @future
    public static void rollupContactsFuture (Set<id> contactIds){
        new RLLP_OppRollup().rollupContacts(getContactById(contactIds));
    }

    /*******************************************************************************************************
    * @description Future wrapper method for updating household rollups from a set of household IDs.
    * @param acctIds A set of household ids.
    * @return void This method does updates directly and returns nothing.
    ********************************************************************************************************/
    @future
    public static void rollupHouseholdsFuture (set<id> hhIDs){
        if (hhIds != null && !hhIds.isEmpty()){
            RLLP_OppRollup_UTIL oppRollupUtil = new RLLP_OppRollup_UTIL();
            map<id, npo02__Household__c> hhmap = new map<id, npo02__Household__c>((list<npo02__Household__c>)Database.query(oppRollupUtil.buildHouseholdQuery() +
                                                                            ' where id IN :hhIDs'));
            RLLP_OppRollup rg = new RLLP_OppRollup();
            rg.rollupHouseholds(hhmap);
        }
    }

    /*******************************************************************************************************
    * @description Runs opportunity rollups for accounts.
    * @param amap A map of account IDs to accounts.
    * @return void This method does updates directly and returns nothing.
    ********************************************************************************************************/
    public void rollupAccounts(map<id, Account> amap) {

        //arg used by multi currency for rollup field currencies
        map<id,Opportunity> opptyCurrencies;

        //create mappings for UDRs if they exist
        Map<String, Object> UDRFieldMap = new Map<String, Object>();

        if (RLLP_OppRollup_UTIL.urfsMap.size() > 0){
            Map<String, Schema.SObjectField> M = Schema.SObjectType.Account.fields.getMap();
                for (string s : RLLP_OppRollup_UTIL.urfsMap.keyset()){
                    if (Account.getSObjectType().getDescribe().getName() == RLLP_OppRollup_UTIL.urfsMap.get(s).npo02__Object_Name__c){
                        npo02__User_Rollup_Field_Settings__c urfs = RLLP_OppRollup_UTIL.urfsMap.get(s);
                        if (M.get(urfs.npo02__Target_Field__c) != null){
                            if (M.get(urfs.npo02__Target_Field__c).getDescribe().getSOAPType() == Schema.Soaptype.Integer || M.get(urfs.npo02__Target_Field__c).getDescribe().getSOAPType() == Schema.Soaptype.Double){
                                UDRFieldMap.put(urfs.npo02__Target_Field__c, 0);
                            }
                        else{
                            UDRFieldMap.put(urfs.npo02__Target_Field__c, null);
                        }
                    }
                }
            }
        }

        // copy the accounts to a map of zerod out versions
        map<id, Account> accountsToUpdate = new map<id, Account>();
        for (id aid : amap.keyset()){

            Account a = new Account(id = aid, npo02__TotalOppAmount__c = 0, npo02__AverageAmount__c = 0,
                npo02__SmallestAmount__c = 0, npo02__LargestAmount__c = 0, npo02__FirstCloseDate__c = null,
                npo02__LastCloseDate__c = null, npo02__NumberOfClosedOpps__c = 0, npo02__OppAmountThisYear__c = 0,
                npo02__OppsClosedThisYear__c = 0, npo02__OppAmountLastYear__c = 0, npo02__OppsClosedLastYear__c = 0,
                npo02__OppsClosed2YearsAgo__c = 0, npo02__OppAmount2YearsAgo__c = 0,
                npo02__OppsClosedLastNDays__c = 0, npo02__OppAmountLastNDays__c = 0,
                npo02__TotalMembershipOppAmount__c = 0, npo02__NumberOfMembershipOpps__c = 0,
                npo02__LastMembershipDate__c = null, npo02__LastMembershipAmount__c = 0,
                npo02__LastMembershipLevel__c = null, npo02__LastMembershipOrigin__c = null,
                npo02__MembershipJoinDate__c = null, npo02__MembershipEndDate__c = null,
                npo02__LastOppAmount__c = null,
                npo02__Best_Gift_Year__c = null, npo02__Best_Gift_Year_Total__c = 0 );

                //add zeroed out UDRs
                for (String s : UDRFieldMap.keySet()){
                    a.put(s, UDRFieldMap.get(s));
                }

            accountsToUpdate.put(aid, a);

            // map currency across if multicurrency
            if(RLLP_OppRollup_UTIL.isMultiCurrency())
                accountsToUpdate.get(aid).put(RLLP_OppRollup_UTIL.mcFieldValues.get('Account'),amap.get(aid).get(RLLP_OppRollup_UTIL.mcFieldValues.get('Account')));
        }

        //need local vars b/c dynamic soql is stupid
        set<id> aset = amap.keySet();
        set<string> typeset = RLLP_OppRollup_UTIL.oppTypesToExcludeAccts;
        set<id> rectypeset = RLLP_OppRollup_UTIL.recordTypesToExcludeAccts;

        RLLP_OppRollup_UTIL oppRollupUtil = new RLLP_OppRollup_UTIL();
        list<sobject> objectList = Database.query(oppRollupUtil.buildAccountRollupQuery());

        // invokes code to get the currency of npo02__CombinedRollupFieldset__c oppty
        opptyCurrencies = (RLLP_OppRollup_UTIL.isMultiCurrency() ? RLLP_OppRollup_UTIL.rcfFindCurrency(objectList) : null);

        for (sobject r : objectList){
            id aid = (id)(r.get('AccountId'));
            if (aid != null){
                updateRollupFromResult((sobject)(accountsToUpdate.get(aid)), r, opptyCurrencies);

                //calculate best gift year
                decimal yrAmt = (decimal)r.get('TotalOppAmount');
                integer yr = (integer)r.get('CalendarYr');
                Account a = accountsToUpdate.get(aid);
                if ((yrAmt > a.npo02__Best_Gift_Year_Total__c || a.npo02__Best_Gift_Year_Total__c==null ) && yr !=null){
                    a.npo02__Best_Gift_Year_Total__c = yrAmt;
                    a.npo02__Best_Gift_Year__c = string.valueOf(yr);
                }
            }
        }

        objectList.clear();
        objectList = database.query(oppRollupUtil.buildAccountNDayQuery());

        for (sobject r : objectList){
            id aid = (id)(r.get('AccountId'));
            if (aid != null)
                updateRollupFromResultLastNDays((sobject)(accountsToUpdate.get(aid)), r);
        }

        if (!RLLP_OppRollup_UTIL.mbrRecordTypes.isEmpty()) {
            set<id> memberset = RLLP_OppRollup_UTIL.mbrRecordTypes;
            objectList.clear();
            objectList = database.query(oppRollupUtil.buildAccountMembershipQuery());

            opptyCurrencies = (RLLP_OppRollup_UTIL.isMultiCurrency() ? RLLP_OppRollup_UTIL.rcfFindCurrency(objectList) : null);

            for (sobject r : objectList){
                id aid = (id)(r.get('AccountId'));
                if (aid != null)
                    updateRollupFromResultMembership((sobject)(accountsToUpdate.get(aid)), r, opptyCurrencies);
            }
        }

        // remove any records that have not changed
        for (id aid : amap.keySet()) {
            account a1 = amap.get(aid);
            account a2 = accountsToUpdate.get(aid);

            if (a1.npo02__TotalOppAmount__c == a2.npo02__TotalOppAmount__c &&
                    a1.npo02__OppsClosedThisYear__c == a2.npo02__OppsClosedThisYear__c &&
                    a1.npo02__OppsClosedLastYear__c == a2.npo02__OppsClosedLastYear__c &&
                    a1.npo02__OppsClosedLastNDays__c == a2.npo02__OppsClosedLastNDays__c &&
                    a1.npo02__OppsClosed2YearsAgo__c == a2.npo02__OppsClosed2YearsAgo__c &&
                    a1.npo02__OppAmountLastYear__c == a2.npo02__OppAmountLastYear__c &&
                    a1.npo02__OppAmount2YearsAgo__c == a2.npo02__OppAmount2YearsAgo__c &&
                    a1.npo02__OppAmountThisYear__c == a2.npo02__OppAmountThisYear__c &&
                    a1.npo02__OppAmountLastNDays__c == a2.npo02__OppAmountLastNDays__c &&
                    a1.npo02__FirstCloseDate__c == a2.npo02__FirstCloseDate__c &&
                    a1.npo02__LastCloseDate__c == a2.npo02__LastCloseDate__c &&
                    a1.npo02__TotalMembershipOppAmount__c == a2.npo02__TotalMembershipOppAmount__c &&
                    a1.npo02__LastMembershipLevel__c == a2.npo02__LastMembershipLevel__c &&
                    a1.npo02__LastMembershipDate__c == a2.npo02__LastMembershipDate__c &&
                    a1.npo02__MembershipJoinDate__c == a2.npo02__MembershipJoinDate__c &&
                    a1.npo02__MembershipEndDate__c == a2.npo02__MembershipEndDate__c &&
                    a1.npo02__Best_Gift_Year__c == a2.npo02__Best_Gift_Year__c &&
                    a1.npo02__Best_Gift_Year_Total__c == a2.npo02__Best_Gift_Year_Total__c &&
                    a1.npo02__AverageAmount__c == a2.npo02__AverageAmount__c &&
                    a1.npo02__LargestAmount__c == a2.npo02__LargestAmount__c &&
                    a1.npo02__SmallestAmount__c == a2.npo02__SmallestAmount__c
                    ){

                if (UDRFieldMap.size() > 0){
                    boolean hasUDRUpdate = false;
                    for (String s : UDRFieldMap.keySet()){
                        if (a1.get(s) != a2.get(s)){
                            hasUDRUpdate = true;
                        }
                    }
                    if (!hasUDRUpdate){
                        accountsToUpdate.remove(aid);
                    }
                }
                else{
                    accountsToUpdate.remove(aid);
                }
            }
        }

        UTIL_DMLService.updateRecordBatchAndLogErrors(accountsToUpdate.values(), ERR_Handler_API.Context.RLLP.name());

    }

    /*******************************************************************************************************
    * @description Runs opportunity rollups for contacts.
    * @param cmap A map of contact IDs to contacts.
    * @return void This method does updates directly and returns nothing.
    ********************************************************************************************************/
    public void rollupContacts(map<id, Contact> cmap){
        //arg used by multi currency for rollup field currencies
        map<Id,Opportunity> opptyCurrencies;

        //create mappings for UDRs if they exist
        Map<String, Object> UDRFieldMap = new Map<String, Object>();

        if (RLLP_OppRollup_UTIL.urfsMap.size() > 0){
            Map<String, Schema.SObjectField> M = Schema.SObjectType.Contact.fields.getMap();
                for (string s : RLLP_OppRollup_UTIL.urfsMap.keyset()){
                    if (Contact.getSObjectType().getDescribe().getName() == RLLP_OppRollup_UTIL.urfsMap.get(s).npo02__Object_Name__c){
                        npo02__User_Rollup_Field_Settings__c urfs = RLLP_OppRollup_UTIL.urfsMap.get(s);
                        if (M.get(urfs.npo02__Target_Field__c) != null){
                            if (M.get(urfs.npo02__Target_Field__c).getDescribe().getSOAPType() == Schema.Soaptype.Integer || M.get(urfs.npo02__Target_Field__c).getDescribe().getSOAPType() == Schema.Soaptype.Double){
                                UDRFieldMap.put(urfs.npo02__Target_Field__c, 0);
                            }
                        else{
                            UDRFieldMap.put(urfs.npo02__Target_Field__c, null);
                        }
                    }
                }
            }
        }

        // copy the contacts to a map of zeroed out versions
        map<id, Contact> contactsToUpdate = new map<id, Contact>();

        for (id cid : cmap.keySet()){
            Contact c = new Contact(id = cid, npo02__TotalOppAmount__c = 0, npo02__AverageAmount__c = 0,
                npo02__SmallestAmount__c = 0, npo02__LargestAmount__c = 0, npo02__FirstCloseDate__c = null,
                npo02__LastCloseDate__c = null, npo02__NumberOfClosedOpps__c = 0, npo02__OppAmountThisYear__c = 0,
                npo02__OppsClosedThisYear__c = 0, npo02__OppAmountLastYear__c = 0, npo02__OppsClosedLastYear__c = 0,
                npo02__OppsClosed2YearsAgo__c = 0, npo02__OppAmount2YearsAgo__c = 0,
                npo02__OppsClosedLastNDays__c = 0, npo02__OppAmountLastNDays__c = 0,
                npo02__TotalMembershipOppAmount__c = 0, npo02__NumberOfMembershipOpps__c = 0,
                npo02__LastMembershipDate__c = null, npo02__LastMembershipAmount__c = 0,
                npo02__LastMembershipLevel__c = null, npo02__LastMembershipOrigin__c = null,
                npo02__MembershipJoinDate__c = null, npo02__MembershipEndDate__c = null,
                npo02__LastOppAmount__c = null,
                npo02__Best_Gift_Year__c = null, npo02__Best_Gift_Year_Total__c = 0);

           //add zeroed out UDRs
            for (String s : UDRFieldMap.keySet()){
                c.put(s, UDRFieldMap.get(s));
            }

            contactsToUpdate.put(cid, c);
            // map currency across if multicurrency
            if(RLLP_OppRollup_UTIL.isMultiCurrency())
                contactsToUpdate.get(cid).put(RLLP_OppRollup_UTIL.mcFieldValues.get('Contact'),cmap.get(cid).get(RLLP_OppRollup_UTIL.mcFieldValues.get('Contact')));
        }

        list<sobject> objectList = new list<sobject>();
        set<id> cset = cmap.keySet();
        set<string> typeset = RLLP_OppRollup_UTIL.oppTypesToExcludeCons;
        set<id> rectypeset = RLLP_OppRollup_UTIL.recordTypesToExcludeCons;

        RLLP_OppRollup_UTIL oppRollupUtil = new RLLP_OppRollup_UTIL();
        objectList = database.query(oppRollupUtil.buildContactRollupQuery());

        // invokes code to get the currency of npo02__CombinedRollupFieldset__c oppty
        opptyCurrencies = (RLLP_OppRollup_UTIL.isMultiCurrency() ? RLLP_OppRollup_UTIL.rcfFindCurrency(objectList) : null);

        for (sobject r : objectList) {
            id cid = (id)(r.get('ContactId'));
            if (cid != null){
                updateRollupFromResult((sobject)(contactsToUpdate.get(cid)), r, opptyCurrencies);

                //calculate best gift year
                decimal yrAmt = (decimal)r.get('TotalOppAmount');
                integer yr = (integer)r.get('CalendarYr');

                Contact c = contactsToUpdate.get(cid);

                if(RLLP_OppRollup_UTIL.isMultiCurrency()) {
                    yrAmt = UTIL_CurrencyConversion.convertFromCorporateUsingStandardRates((string)c.get('CurrencyIsoCode'),yrAmt);
                }

                if ((yrAmt > c.npo02__Best_Gift_Year_Total__c || c.npo02__Best_Gift_Year_Total__c==null ) && yr !=null){
                    c.npo02__Best_Gift_Year_Total__c = yrAmt;
                    c.npo02__Best_Gift_Year__c = string.valueOf(yr);
                }
            }
        }

        objectList.clear();
        objectList = database.query(oppRollupUtil.buildContactNDayQuery());

        for (sobject r : objectList){
            id cid = (id)(r.get('ContactId'));
            if (cid != null)
                updateRollupFromResultLastNDays((sobject)(contactsToUpdate.get(cid)), r);
        }

        if (!RLLP_OppRollup_UTIL.mbrRecordTypes.isEmpty()){
            set<id> memberset = RLLP_OppRollup_UTIL.mbrRecordTypes;
            objectList.clear();
            objectList = database.query(oppRollupUtil.buildContactMembershipQuery());

            opptyCurrencies = (RLLP_OppRollup_UTIL.isMultiCurrency() ? RLLP_OppRollup_UTIL.rcfFindCurrency(objectList) : null);

            for (sobject r : objectList){
                id cid = (id)(r.get('ContactId'));
                if (cid != null)
                    updateRollupFromResultMembership((sobject)(contactsToUpdate.get(cid)), r, opptyCurrencies);
            }
        }

        for (id cid : cmap.keySet()) {
            contact c1 = cmap.get(cid);
            contact c2 = contactsToUpdate.get(cid);

            if (c1.npo02__TotalOppAmount__c == c2.npo02__TotalOppAmount__c &&
                    c1.npo02__OppsClosedThisYear__c == c2.npo02__OppsClosedThisYear__c &&
                    c1.npo02__OppsClosedLastYear__c == c2.npo02__OppsClosedLastYear__c &&
                    c1.npo02__OppsClosedLastNDays__c == c2.npo02__OppsClosedLastNDays__c &&
                    c1.npo02__OppsClosed2YearsAgo__c == c2.npo02__OppsClosed2YearsAgo__c &&
                    c1.npo02__OppAmountLastYear__c == c2.npo02__OppAmountLastYear__c &&
                    c1.npo02__OppAmount2YearsAgo__c == c2.npo02__OppAmount2YearsAgo__c &&
                    c1.npo02__OppAmountThisYear__c == c2.npo02__OppAmountThisYear__c &&
                    c1.npo02__OppAmountLastNDays__c == c2.npo02__OppAmountLastNDays__c &&
                    c1.npo02__FirstCloseDate__c == c2.npo02__FirstCloseDate__c &&
                    c1.npo02__LastCloseDate__c == c2.npo02__LastCloseDate__c &&
                    c1.npo02__TotalMembershipOppAmount__c == c2.npo02__TotalMembershipOppAmount__c &&
                    c1.npo02__LastMembershipLevel__c == c2.npo02__LastMembershipLevel__c &&
                    c1.npo02__LastMembershipDate__c == c2.npo02__LastMembershipDate__c &&
                    c1.npo02__MembershipJoinDate__c == c2.npo02__MembershipJoinDate__c &&
                    c1.npo02__MembershipEndDate__c == c2.npo02__MembershipEndDate__c &&
                    c1.npo02__Best_Gift_Year__c == c2.npo02__Best_Gift_Year__c &&
                    c1.npo02__Best_Gift_Year_Total__c == c2.npo02__Best_Gift_Year_Total__c &&
                    c1.npo02__AverageAmount__c == c2.npo02__AverageAmount__c &&
                    c1.npo02__LargestAmount__c == c2.npo02__LargestAmount__c &&
                    c1.npo02__SmallestAmount__c == c2.npo02__SmallestAmount__c
                    ){

                if (UDRFieldMap.size() > 0){
                    boolean hasUDRUpdate = false;
                    for (String s : UDRFieldMap.keySet()){
                        if (c1.get(s) != c2.get(s)){
                            hasUDRUpdate = true;
                        }
                    }
                    if (!hasUDRUpdate){
                        contactsToUpdate.remove(cid);
                    }
                }
                else{
                    contactsToUpdate.remove(cid);
                }
            }
        }

        UTIL_DMLService.updateRecordBatchAndLogErrors(contactsToUpdate.values(), ERR_Handler_API.Context.RLLP.name());
    }

    /*******************************************************************************************************
    * @description Runs opportunity rollups for households.
    * @param hhmap A map of contact IDs to households.
    * @return void This method does updates directly and returns nothing.
    ********************************************************************************************************/
    public void rollupHouseholds(map<id, npo02__Household__c> hhmap){
        //arg used by multi currency for rollup field currencies
        map<Id,Opportunity> opptyCurrencies;

        //create mappings for UDRs if they exist
        Map<String, Object> UDRFieldMap = new Map<String, Object>();

        if (RLLP_OppRollup_UTIL.urfsMap.size() > 0){
            Map<String, Schema.SObjectField> M = Schema.SObjectType.npo02__Household__c.fields.getMap();
                for (string s : RLLP_OppRollup_UTIL.urfsMap.keyset()){
                    if (npo02__Household__c.getSObjectType().getDescribe().getName() == RLLP_OppRollup_UTIL.urfsMap.get(s).npo02__Object_Name__c){
                        npo02__User_Rollup_Field_Settings__c urfs = RLLP_OppRollup_UTIL.urfsMap.get(s);
                        if (M.get(urfs.npo02__Target_Field__c) != null){
                            if (M.get(urfs.npo02__Target_Field__c).getDescribe().getSOAPType() == Schema.Soaptype.Integer || M.get(urfs.npo02__Target_Field__c).getDescribe().getSOAPType() == Schema.Soaptype.Double){
                                UDRFieldMap.put(urfs.npo02__Target_Field__c, 0);
                            }
                        else{
                            UDRFieldMap.put(urfs.npo02__Target_Field__c, null);
                        }
                    }
                }
            }
        }

        // copy the contacts and households to a map of zerod out versions
        map<id, npo02__Household__c> householdsToUpdate = new map<id, npo02__Household__c>();

        for (id hhid : hhmap.keySet()) {
            npo02__Household__c h = new npo02__Household__c(id = hhid, npo02__TotalOppAmount__c = 0, npo02__AverageAmount__c = 0,
                npo02__SmallestAmount__c = 0, npo02__LargestAmount__c = 0, npo02__FirstCloseDate__c = null,
                npo02__LastCloseDate__c = null, npo02__NumberOfClosedOpps__c = 0, npo02__OppAmountThisYear__c = 0,
                npo02__OppsClosedThisYear__c = 0, npo02__OppAmountLastYear__c = 0, npo02__OppsClosedLastYear__c = 0,
                npo02__OppsClosed2YearsAgo__c = 0, npo02__OppAmount2YearsAgo__c = 0,
                npo02__OppsClosedLastNDays__c = 0, npo02__OppAmountLastNDays__c = 0,
                npo02__TotalMembershipOppAmount__c = 0, npo02__NumberOfMembershipOpps__c = 0,
                npo02__LastMembershipDate__c = null, npo02__LastMembershipAmount__c = 0,
                npo02__LastMembershipLevel__c = null, npo02__LastMembershipOrigin__c = null,
                npo02__MembershipJoinDate__c = null, npo02__MembershipEndDate__c = null,
                npo02__LastOppAmount__c = null,
                npo02__Best_Gift_Year__c = null, npo02__Best_Gift_Year_Total__c = 0);

            //add zeroed out UDRs
            for (String s : UDRFieldMap.keySet()){
                h.put(s, UDRFieldMap.get(s));
            }

            householdsToUpdate.put(hhid, h);

            // map currency across if multicurrency
            if(RLLP_OppRollup_UTIL.isMultiCurrency())
                householdsToUpdate.get(hhid).put(RLLP_OppRollup_UTIL.mcFieldValues.get('npo02__Household__c'),hhmap.get(hhid).get(RLLP_OppRollup_UTIL.mcFieldValues.get('npo02__Household__c')));
        }

        list<sobject> objectList = new list<sobject>();
        set<id> hhset = hhmap.keySet();
        set<string> typeset = RLLP_OppRollup_UTIL.oppTypesToExcludeCons;
        set<id> rectypeset = RLLP_OppRollup_UTIL.recordTypesToExcludeCons;

        RLLP_OppRollup_UTIL oppRollupUtil = new RLLP_OppRollup_UTIL();
        objectList = database.query(oppRollupUtil.buildHouseholdRollupQuery());

        // invokes code to get the currency of npo02__CombinedRollupFieldset__c oppty
        opptyCurrencies = (RLLP_OppRollup_UTIL.isMultiCurrency() ? RLLP_OppRollup_UTIL.rcfFindCurrency(objectList) : null);

        for (sobject r : objectList) {
            id hhid = (id)(r.get('hhid'));
            if (hhid != null){
                updateRollupFromResult((sobject)(householdsToUpdate.get(hhid)), r, opptyCurrencies);

                //calculate best gift year
                decimal yrAmt = (decimal)r.get('TotalOppAmount');
                integer yr = (integer)r.get('CalendarYr');
                npo02__Household__c hh = householdsToUpdate.get(hhid);
                if ((yrAmt > hh.npo02__Best_Gift_Year_Total__c || hh.npo02__Best_Gift_Year_Total__c==null ) && yr !=null){
                    hh.npo02__Best_Gift_Year_Total__c = yrAmt;
                    hh.npo02__Best_Gift_Year__c = string.valueOf(yr);
                }
            }
        }

        objectList.clear();
        objectList = database.query(oppRollupUtil.buildHouseholdNDayQuery());

        for (sobject r : objectList){
            id hhid = (id)(r.get('hhid'));
            if (hhid != null)
                updateRollupFromResultLastNDays((sobject)(householdsToUpdate.get(hhid)), r);
        }

        if (!RLLP_OppRollup_UTIL.mbrRecordTypes.isEmpty()){
            set<id> memberset = RLLP_OppRollup_UTIL.mbrRecordTypes;
            objectList.clear();
            objectList = database.query(oppRollupUtil.buildHouseholdMembershipQuery());

            opptyCurrencies = (RLLP_OppRollup_UTIL.isMultiCurrency() ? RLLP_OppRollup_UTIL.rcfFindCurrency(objectList) : null);

            for (sobject r : objectList){
                id hhid = (id)(r.get('hhid'));
                if (hhid != null)
                    updateRollupFromResultMembership((sobject)(householdsToUpdate.get(hhid)), r, opptyCurrencies);
            }
        }

        for (id hhid : hhmap.keySet()) {
            npo02__Household__c h1 = hhmap.get(hhid);
            npo02__Household__c h2 = householdsToUpdate.get(hhid);

            if (h1.npo02__TotalOppAmount__c == h2.npo02__TotalOppAmount__c &&
                    h1.npo02__OppsClosedThisYear__c == h2.npo02__OppsClosedThisYear__c &&
                    h1.npo02__OppsClosedLastYear__c == h2.npo02__OppsClosedLastYear__c &&
                    h1.npo02__OppsClosedLastNDays__c == h2.npo02__OppsClosedLastNDays__c &&
                    h1.npo02__OppsClosed2YearsAgo__c == h2.npo02__OppsClosed2YearsAgo__c &&
                    h1.npo02__OppAmountLastYear__c == h2.npo02__OppAmountLastYear__c &&
                    h1.npo02__OppAmount2YearsAgo__c == h2.npo02__OppAmount2YearsAgo__c &&
                    h1.npo02__OppAmountThisYear__c == h2.npo02__OppAmountThisYear__c &&
                    h1.npo02__OppAmountLastNDays__c == h2.npo02__OppAmountLastNDays__c &&
                    h1.npo02__FirstCloseDate__c == h2.npo02__FirstCloseDate__c &&
                    h1.npo02__LastCloseDate__c == h2.npo02__LastCloseDate__c &&
                    h1.npo02__TotalMembershipOppAmount__c == h2.npo02__TotalMembershipOppAmount__c &&
                    h1.npo02__LastMembershipLevel__c == h2.npo02__LastMembershipLevel__c &&
                    h1.npo02__LastMembershipDate__c == h2.npo02__LastMembershipDate__c &&
                    h1.npo02__MembershipJoinDate__c == h2.npo02__MembershipJoinDate__c &&
                    h1.npo02__MembershipEndDate__c == h2.npo02__MembershipEndDate__c &&
                    h1.npo02__Best_Gift_Year__c == h2.npo02__Best_Gift_Year__c &&
                    h1.npo02__Best_Gift_Year_Total__c == h2.npo02__Best_Gift_Year_Total__c &&
                    h1.npo02__AverageAmount__c == h2.npo02__AverageAmount__c &&
                    h1.npo02__LargestAmount__c == h2.npo02__LargestAmount__c &&
                    h1.npo02__SmallestAmount__c == h2.npo02__SmallestAmount__c
                    ){

            if (UDRFieldMap.size() > 0){
                    boolean hasUDRUpdate = false;
                    for (String s : UDRFieldMap.keySet()){
                        if (h1.get(s) != h2.get(s)){
                            hasUDRUpdate = true;
                        }
                    }
                    if (!hasUDRUpdate){
                        householdsToUpdate.remove(hhid);
                    }
                }
                else{
                    householdsToUpdate.remove(hhid);
                }
            }
        }

        UTIL_DMLService.updateRecordBatchAndLogErrors(householdsToUpdate.values(), ERR_Handler_API.Context.RLLP.name());
    }

    /*******************************************************************************************************
    * @description Runs opportunity soft credit rollups for contacts.
    * @param list The list of contacts to rollup to.
    * @return void This method does updates directly and returns nothing.
    ********************************************************************************************************/
    public void rollupSoftCreditsWithPartialSupport(list<Contact> listCon) {
        RLLP_OppPartialSoftCreditRollup.rollupPartialSoftCredits(listCon);
    }

    /*******************************************************************************************************
    * @description Runs opportunity soft credit rollups for contacts.
    * NO LONGER USED SINCE DOES NOT SUPPORT PARTIAL SOFT CREDITS.  Can be removed once we are done testing.
    * @param cmap A map of contact IDs to contacts.
    * @return void This method does updates directly and returns nothing.
    public void rollupSoftCreditsOLDNoPartialSupport(map<id, Contact> cmap){
        //arg used by multi currency for rollup field currencies
        map<Id,Opportunity> opptyCurrencies;
        // copy the contacts to a zeroed out version
        map<id, Contact> contactsToUpdate = new map<id, Contact>();

        for (id cid : cmap.keySet()) {
            contactsToUpdate.put(cid, new Contact(id = cid,
                npo02__Soft_Credit_This_Year__c = 0, npo02__Soft_Credit_Last_Year__c = 0,
                npo02__Soft_Credit_Two_Years_Ago__c = 0, npo02__Soft_Credit_Total__c = 0, Soft_Credit_Last_N_Days__c = 0
            ));
            // map currency across if multicurrency
            if(RLLP_OppRollup_UTIL.isMultiCurrency())
                contactsToUpdate.get(cid).put(RLLP_OppRollup_UTIL.mcFieldValues.get('Contact'),cmap.get(cid).get(RLLP_OppRollup_UTIL.mcFieldValues.get('Contact')));
        }

        list<sobject> objectList = new list<sobject>();
        set<id> cset = cmap.keySet();
        set<string> softCreditRoles = RLLP_OppRollup_UTIL.softCreditRoles;
        set<string> typeset = RLLP_OppRollup_UTIL.oppTypesToExcludeCons;
        set<id> rectypeset = RLLP_OppRollup_UTIL.recordTypesToExcludeCons;

        RLLP_OppRollup_UTIL oppRollupUtil = new RLLP_OppRollup_UTIL();
        objectList = database.query(oppRollupUtil.buildSoftCreditQuery());

        // invokes code to get the currency of npo02__CombinedRollupFieldset__c oppty
        opptyCurrencies = (RLLP_OppRollup_UTIL.isMultiCurrency() ? RLLP_OppRollup_UTIL.rcfFindCurrency(objectList) : null);

        for (sobject r : objectList) {
            id cid = (id)(r.get('ContactId'));
            if (cid != null){
                updateSoftCreditFromResult((sobject)(contactsToUpdate.get(cid)), r, opptyCurrencies);
            }
        }

        objectList.clear();
        objectList = database.query(oppRollupUtil.buildContactNDaySoftCreditQuery());

        for (sobject r : objectList){
            id cid = (id)(r.get('ContactId'));
            if (cid != null)
                updateSoftCreditRollupFromResultLastNDays((sobject)(contactsToUpdate.get(cid)), r);
        }

        for (id cid : cmap.keySet()) {
            contact c1 = cmap.get(cid);
            contact c2 = contactsToUpdate.get(cid);

            if (c1.npo02__Soft_Credit_This_Year__c == c2.npo02__Soft_Credit_This_Year__c &&
                c1.npo02__Soft_Credit_Last_Year__c == c2.npo02__Soft_Credit_Last_Year__c &&
                c1.npo02__Soft_Credit_Two_Years_Ago__c == c2.npo02__Soft_Credit_Two_Years_Ago__c &&
                c1.Soft_Credit_Last_N_Days__c == c2.Soft_Credit_Last_N_Days__c &&
                c1.npo02__Soft_Credit_Total__c == c2.npo02__Soft_Credit_Total__c)
                contactsToUpdate.remove(cid);
        }

        update contactsToUpdate.values();
    }
    ********************************************************************************************************/

    /*******************************************************************************************************
    * @description Runs all batch opportunity rollups for all records on all objects.
    * @return void This method does updates directly and returns nothing.
    ********************************************************************************************************/
    public void rollupAll(){

        //clear the error queue from any previous runs
        delete [select id from Error__c where Context_Type__c = 'RLLP'];

        rollupAllAccounts();
        rollupAllContacts();
        rollupAllHouseholds();

        if (RLLP_OppRollup_UTIL.useSoftCredits()){
            rollupAllSoftCredits();
        }
    }
    /*******************************************************************************************************
    * @description Runs batch opportunity rollups for all accounts.
    * @return void This method does updates directly and returns nothing.
    ********************************************************************************************************/
    public void rollupAllAccounts() {
        RLLP_OppAccRollup_BATCH batch = new RLLP_OppAccRollup_BATCH();
        id batchProcessId = database.executeBatch(batch, CRLP_RollupBatch_SVC.getBatchSize(
                CRLP_RollupProcessingOptions.RollupType.AccountHardCredit, CRLP_RollupProcessingOptions.BatchJobMode.NonSkewMode));
    }
    /*******************************************************************************************************
    * @description Runs batch opportunity rollups for all contacts.
    * @return void This method does updates directly and returns nothing.
    ********************************************************************************************************/
    public void rollupAllContacts() {
        RLLP_OppContactRollup_BATCH batch = new RLLP_OppContactRollup_BATCH();
        id batchProcessId = database.executeBatch(batch, CRLP_RollupBatch_SVC.getBatchSize(
                CRLP_RollupProcessingOptions.RollupType.ContactHardCredit, CRLP_RollupProcessingOptions.BatchJobMode.NonSkewMode));
    }
    /*******************************************************************************************************
    * @description Runs batch opportunity rollups for all households.
    * @return void This method does updates directly and returns nothing.
    ********************************************************************************************************/
    public void rollupAllHouseholds(){
        RLLP_OppHouseholdRollup_BATCH batch = new RLLP_OppHouseholdRollup_BATCH();
        id batchProcessId = database.executeBatch(batch, CRLP_RollupBatch_SVC.getBatchSize(
                CRLP_RollupProcessingOptions.RollupType.AccountHardCredit, CRLP_RollupProcessingOptions.BatchJobMode.NonSkewMode));
    }
    /*******************************************************************************************************
    * @description Runs batch opportunity soft credit rollups for all contacts.
    * @return void This method does updates directly and returns nothing.
    ********************************************************************************************************/
    public void rollupAllSoftCredits(){
        RLLP_OppSoftCreditRollup_BATCH batch = new RLLP_OppSoftCreditRollup_BATCH();
        id batchProcessId = database.executeBatch(batch, CRLP_RollupBatch_SVC.getBatchSize(
                CRLP_RollupProcessingOptions.RollupType.ContactSoftCredit, CRLP_RollupProcessingOptions.BatchJobMode.NonSkewMode));
    }

    /*******************************************************************************************************
    * @description Method writes rollup fields from AggregateResults to an object needing rollups.
    * @param obj The object to roll up to.
    * @param aggrResultObj The aggregate result object.
    * @param opptyCurrencies Holds opportunity currency codes for multicurrency orgs.
    * @return void This method does updates directly and returns nothing.
    ********************************************************************************************************/
    public static void updateRollupFromResult(Sobject obj, Sobject aggrResultObj, Map<Id, Opportunity> opptyCurrencies) {
       // get the fiscal year, total amount, and opp count for this result row
        Integer fy = (integer)(aggrResultObj.get('CalendarYr'));
        Decimal amt = (decimal)(aggrResultObj.get('TotalOppAmount'));
        Integer cnt = (integer)(aggrResultObj.get('NumberOfClosedOpps'));

        // split the special field to get the last opp id and amount
        String[] rcf = ((string)(aggrResultObj.get('RollupFieldset'))).split(';\\|;',-4);
        Decimal lastAmt = (rcf.size() > 1 && rcf[1] != '') ? decimal.valueOf(rcf[1]) : null;

        // calculate amounts into correct currency if needed
        if(RLLP_OppRollup_UTIL.isMultiCurrency()){
            amt = UTIL_CurrencyConversion.convertFromCorporateUsingStandardRates((string)obj.get('CurrencyIsoCode'),amt);
            if(lastAmt != null && rcf.size() > 4 && rcf[4] != '') {
                lastAmt = UTIL_CurrencyConversion.convertAmountUsingStandardRates((string)opptyCurrencies.get((Id)rcf[4]).get('CurrencyISOCode'),(string)obj.get('CurrencyIsoCode'),lastAmt);
            }
        }

        // check if this is an annual total or account total
        if (fy != null){

            // put the fiscal year total in the right fields
            Integer thisYear;
            if (RLLP_OppRollup_UTIL.useFiscalYear) {
                thisYear = RLLP_OppRollup_UTIL.getCurrentFY();
            } else {
                thisYear = system.today().year();
            }

            if (fy == thisYear){
                obj.put('npo02__OppAmountThisYear__c', amt);
                obj.put('npo02__OppsClosedThisYear__c', cnt);
            }
            else if (fy == (thisYear - 1)){
                obj.put('npo02__OppAmountLastYear__c', amt);
                obj.put('npo02__OppsClosedLastYear__c', cnt);
            }
            else if (fy == (thisYear - 2) ){
                obj.put('npo02__OppAmount2YearsAgo__c', amt);
                obj.put('npo02__OppsClosed2YearsAgo__c', cnt);
            }
        } else {
            // fill in summary totals
            obj.put('npo02__TotalOppAmount__c', amt);
            obj.put('npo02__NumberOfClosedOpps__c', cnt);
            obj.put('npo02__LastOppAmount__c', lastAmt);
            obj.put('npo02__FirstCloseDate__c', aggrResultObj.get('FirstCloseDate')); //date
            obj.put('npo02__LastCloseDate__c', aggrResultObj.get('LastCloseDate')); //date

            // calculate amounts into correct currency if needed
            if(RLLP_OppRollup_UTIL.isMultiCurrency()){
                String toCurrCode = (string)obj.get('CurrencyIsoCode');
                obj.put('npo02__AverageAmount__c', UTIL_CurrencyConversion.convertFromCorporateUsingStandardRates(toCurrCode,(decimal)aggrResultObj.get('AverageAmount')));
                obj.put('npo02__SmallestAmount__c', UTIL_CurrencyConversion.convertFromCorporateUsingStandardRates(toCurrCode,(decimal)aggrResultObj.get('SmallestAmount')));
                obj.put('npo02__LargestAmount__c', UTIL_CurrencyConversion.convertFromCorporateUsingStandardRates(toCurrCode,(decimal)aggrResultObj.get('LargestAmount')));
            }
            else{
               obj.put('npo02__AverageAmount__c', (decimal)(aggrResultObj.get('AverageAmount')));
               obj.put('npo02__SmallestAmount__c', (decimal)(aggrResultObj.get('SmallestAmount')));
               obj.put('npo02__LargestAmount__c', (decimal)(aggrResultObj.get('LargestAmount')));
            }
        }

        // Deal with user defined rollups
        if (RLLP_OppRollup_UTIL.urfsMap.size() > 0){
            // For each UDR
            for (String s : RLLP_OppRollup_UTIL.urfsMap.keyset()){

                // If the current rollup object matches the User Rollup Object
                if (obj.getSObjectType().getDescribe().getName() == RLLP_OppRollup_UTIL.urfsMap.get(s).npo02__Object_Name__c) {
                    npo02__User_Rollup_Field_Settings__c udr = RLLP_OppRollup_UTIL.urfsMap.get(s);
                    String rollupName = udr.Name;

                    // If there is an aggregate result for this UDR
                    if (aggrResultObj.get(rollupName) != null) {
                        // Calculate amounts into correct currency only if the field is a Currency type field
                        Schema.DescribeFieldResult fld = UTIL_Describe.getFieldDescribe('Opportunity', udr.npo02__Source_Field__c);
                        if (fld.getType() == Schema.Displaytype.Currency && RLLP_OppRollup_UTIL.isMultiCurrency()) {
                            obj.put(udr.npo02__Target_Field__c, UTIL_CurrencyConversion.convertFromCorporateUsingStandardRates((string) obj.get('CurrencyIsoCode'), (decimal) aggrResultObj.get(rollupName)));
                        } else {
                            obj.put(udr.npo02__Target_Field__c, aggrResultObj.get(rollupName));
                        }
                    }
                }
            }
        }
    }

    /*******************************************************************************************************
    * @description Method writes Last N Days rollup fields from AggregateResults to an object needing rollups.
    * @param obj The object to roll up to.
    * @param r The aggregate result object.
    * @return void This method does updates directly and returns nothing.
    ********************************************************************************************************/
    public static void updateRollupFromResultLastNDays(sobject obj, sobject r){

        // get the fiscal year, total amount, and opp count for this result row
        decimal amt = (decimal)(r.get('TotalOppAmount'));
        integer cnt = (integer)(r.get('NumberOfClosedOpps'));

        // calculate amounts into correct currency if needed
        if(RLLP_OppRollup_UTIL.isMultiCurrency()) {
            amt = UTIL_CurrencyConversion.convertFromCorporateUsingStandardRates((string)obj.get('CurrencyIsoCode'),amt);
        }

        obj.put('npo02__OppAmountLastNDays__c', amt);
        obj.put('npo02__OppsClosedLastNDays__c', cnt);
    }

    /*******************************************************************************************************
    * @description Method writes membership rollup fields from AggregateResults to an object needing rollups.
    * @param obj The object to roll up to.
    * @param r The aggregate result object.
    * @param opptyCurrencies Holds opportunity currency codes for multicurrency orgs.
    * @return void This method does updates directly and returns nothing.
    ********************************************************************************************************/
    public static void updateRollupFromResultMembership(sobject obj, sobject r, map<id, Opportunity> opptyCurrencies){
    // used for single and batch rollups, this maps query results to the right fields

        // get the fiscal year, total amount, and opp count for this result row
        decimal amt = (decimal)(r.get('TotalOppAmount'));
        integer cnt = (integer)(r.get('NumberOfClosedOpps'));

        // split the special field to get the last opp id and amount
        string[] rcf = ((string)(r.get('RollupFieldset'))).split(';\\|;',-4);
        decimal lastAmt = (rcf.size() > 1 && rcf[1] != null) ? decimal.valueOf(rcf[1]) : null;
        string lastMemberLevel = (rcf.size() > 2) ? rcf[2] : null;
        string lastMemberOrigin = (rcf.size() > 3) ? rcf[3] : null;
        // calculate amounts into correct currency if needed
        if(RLLP_OppRollup_UTIL.isMultiCurrency()){
            amt = UTIL_CurrencyConversion.convertFromCorporateUsingStandardRates((string)obj.get('CurrencyIsoCode'),amt);
            if(lastAmt != null && rcf.size() > 4 && rcf[4] != '') {
                lastAmt = UTIL_CurrencyConversion.convertAmountUsingStandardRates((string)opptyCurrencies.get((Id)rcf[4]).get('CurrencyISOCode'),(string)obj.get('CurrencyIsoCode'),lastAmt);
            }
        }

        // fill in summary totals
        obj.put('npo02__TotalMembershipOppAmount__c', amt);
        obj.put('npo02__NumberOfMembershipOpps__c', cnt);
        obj.put('npo02__LastMembershipDate__c', (date)(r.get('LastCloseDate')));
        obj.put('npo02__LastMembershipAmount__c', lastAmt);
        obj.put('npo02__MembershipJoinDate__c', (date)(r.get('FirstStartDate')));
        obj.put('npo02__MembershipEndDate__c', (date)(r.get('LastEndDate')));
        // Force an empty string ("") to null to ensure the comparison to the db field matches.
        obj.put('npo02__LastMembershipLevel__c', (String.isEmpty(lastMemberLevel) ? null : lastMemberLevel));
        obj.put('npo02__LastMembershipOrigin__c', (String.isEmpty(lastMemberOrigin) ? null : lastMemberOrigin));
    }

    /*******************************************************************************************************
    * @description Method writes soft credit rollup fields from AggregateResults to an object needing rollups.
    * @param obj The object to roll up to.
    * @param r The aggregate result object.
    * @param opptyCurrencies Holds opportunity currency codes for multicurrency orgs.
    * @return void This method does updates directly and returns nothing.
    public static void updateSoftCreditFromResult(sobject obj, sobject r, map<id, Opportunity> opptyCurrencies){
         // get the fiscal year, total amount, and opp count for this result row
        integer fy = (integer)(r.get('CalendarYr'));
        decimal amt = (decimal)(r.get('TotalOppAmount'));

        // calculate amounts into correct currency if needed
        if(RLLP_OppRollup_UTIL.isMultiCurrency())
            amt = UTIL_CurrencyConversion.convertFromCorporateUsingStandardRates((string)obj.get('CurrencyIsoCode'),amt);

        // check if this is an annual total or account total
        if (fy != null){

            // put the fiscal year total in the right fields
            integer thisYear;
            if (RLLP_OppRollup_UTIL.useFiscalYear)
                thisYear = RLLP_OppRollup_UTIL.getCurrentFY();
            else
                thisYear = system.today().year();

            if (fy == thisYear)
                obj.put('npo02__Soft_Credit_This_Year__c', amt);

            else if (fy == (thisYear - 1))
                obj.put('npo02__Soft_Credit_Last_Year__c', amt);

            else if (fy == (thisYear - 2))
                obj.put('npo02__Soft_Credit_Two_Years_Ago__c', amt);
        }
        else {
            // fill in summary totals
            obj.put('npo02__Soft_Credit_Total__c', amt);
        }
    }
    ********************************************************************************************************/

     /*******************************************************************************************************
    * @description Method writes soft credit last N days rollup fields from AggregateResults to an object
    * needing rollups.
    * @param obj The object to roll up to.
    * @param r The aggregate result object.
    * @return void This method does updates directly and returns nothing.
   public static void updateSoftCreditRollupFromResultLastNDays(sobject obj, sobject r){

        // get the total amount for this result row
        decimal amt = (decimal)(r.get('TotalOppAmount'));

        // calculate amounts into correct currency if needed
        if(RLLP_OppRollup_UTIL.isMultiCurrency())
           amt = UTIL_CurrencyConversion.convertFromCorporateUsingStandardRates((string)obj.get('CurrencyIsoCode'),amt);

        obj.put('Soft_Credit_Last_N_Days__c', amt);
    }
    ********************************************************************************************************/
}