/*
    Copyright (c) 2018, Salesforce.org
    All rights reserved.

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Salesforce.org nor the names of
      its contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
    FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
    COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
    INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
    BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
    LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
    ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
    POSSIBILITY OF SUCH DAMAGE.
*/
/**
* @author Salesforce.org
* @date 2018
* @group Rollups
* @group-content ../../ApexDocContent/Rollups2.htm
* @description Customizable Rollups service methods specific to Batch and Queueable rollup operations
*
*/
public class CRLP_RollupProcessor_SVC {

    /**
     * @description Returns the Type of the appropriate CRLP_RollupXXXX_SVC class to use for handling the
     * rollups based on the SObjectType of the Summary object
     * @param rollupType Rollup Type
     * @return ApexClassType
     */
    public static Type getHandlerClassType(CRLP_RollupProcessingOptions.RollupType rollupType) {
        Type handlerClass;
        switch on (rollupType) {
            when ContactSoftCredit, AccountContactSoftCredit {
                handlerClass = CRLP_RollupSoftCredit_SVC.class;
            }
            when AccountSoftCredit {
                handlerClass = CRLP_RollupAccSoftCredit_SVC.class;
            }
            when AccountHardCredit {
                handlerClass = CRLP_RollupAccount_SVC.class;
            }
            when ContactHardCredit {
                handlerClass = CRLP_RollupContact_SVC.class;
            }
            when GAU {
                handlerClass = CRLP_RollupGAU_SVC.class;
            }
            when RecurringDonations {
                handlerClass = CRLP_RollupRD_SVC.class;
            }
        }
        return handlerClass;
    }


    /**
     * @description Called by the same method that calls the startProcessing() method to handle any dml operations
     * and log any dml errors that were generated by the update
     * @param recordsToUpdate List<SObject>
     */
    public static void updateChangedRecordsWithLogging(List<SObject> recordsToUpdate, CRLP_RollupProcessingOptions.RollupType jobType) {
        Map<Id,String> dmlErrors = new Map<Id, String>();

        if (recordsToUpdate.isEmpty()) {
            return;
        }

        // Disable non-User Managed TDTM triggers before the DML operation to improve performance when
        // writing changes to rollups to the target objects.
        String targetObjectName = UTIL_Describe.getObjectDescribe(recordsToUpdate[0].getSObjectType()).getName();
        for (Trigger_Handler__c th : TDTM_Config_API.getCachedRecords()) {
            if (th.User_Managed__c == false && th.Object__c == targetObjectName) {
                th.Active__c = false;
            }
        }

        // Initiate the DML operation with allOrNone set to false (don't fail the entire batch if one record fails)
        UTIL_DMLService.updateRecordBatchAndLogErrors(recordsToUpdate, ERR_Handler_API.Context.CRLP.name() + '.' + jobType.name());
    }

    /**
     * @description If a query includes a sub-query of child records and that list of children is needed as a
     * separate collection (specifically with Payments), this will return a Map of list child records with the map
     * key of the parent record id.
     * @param details List<SObject>
     * @param relationshipName Name of the relationship field to use to split the child sub-query
     * @return Map<Id, List<SObject>>
     */
    public static Map<Id, List<SObject>> splitChildRecordsInMapByParentId(List<SObject> details, String relationshipName) {
        Map<Id, List<SObject>> childrenByParentId = new Map<Id, List<SObject>>();
        for (SObject d : details) {
            if (relationshipName != null && d.getSObjects(relationshipName) != null) {
                childrenByParentId.put(d.Id, d.getSObjects(relationshipName));
            }
        }
        return childrenByParentId;
    }

    /**
     * @description In order to ensure that the List<CRLP_Rollup> values that are created and saved, as well
     * as cached properly, the individual instances of CRLP_Rollup have to be cloned. Otherwise, Salesforce
     * treats each element by reference meaning that we always end up with a single collection of these that is
     * continually passed around by reference. Cloning the entire list simply creates a new reference to the List,
     * but each individual instance of CRLP_Rollup is still a reference to the original. The only way to work around
     * this is to clone each individual instance into a new list.
     * @param rollups List<CRLP_Rollup> to clone
     * @return Fully cloned list of CRLP_Rollup
     */
    public static List<CRLP_Rollup> fullyCloneList(List<CRLP_Rollup> rollups) {
        List<CRLP_Rollup> newList = new List<CRLP_Rollup>();
        for (CRLP_Rollup r : rollups) {
            CRLP_Rollup clonedRollup = r.clone();
            clonedRollup.rollupsMdt = new List<CRLP_Rollup.Rollupmdt>();
            for (CRLP_Rollup.Rollupmdt rmdt : r.rollupsMdt) {
                clonedRollup.rollupsMdt.add(rmdt.clone());
            }
            newList.add(clonedRollup);
        }
        return newList;
    }
}