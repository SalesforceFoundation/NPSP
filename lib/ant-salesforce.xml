<project xmlns:sf="antlib:com.salesforce">

  <!-- Following typedefs and macro definitions are from https://gist.github.com/afawcett/5843110 -->
  <!--   Download from Salesforce Tools page under Setup -->
  <typedef 
      uri="antlib:com.salesforce" 
      resource="com/salesforce/antlib.xml" 
      classpath="${basedir}/lib/ant-salesforce.jar"/>
      
  <!--   Download from http://sourceforge.net/projects/ant-contrib/files/ant-contrib/1.0b3/ -->
  <taskdef 
      resource="net/sf/antcontrib/antlib.xml" 
      classpath="${basedir}/lib/ant-contrib-1.0b2.jar"
      />  

  <!-- load whitelists -->
  <loadproperties srcFile="${basedir}/lib/whitelists/object_subtype.properties"/>
  <loadfile property="metadata_whitelist" srcfile="lib/whitelists/metadata.txt" />

  <!-- Ant doesn't like < in replace tokens or values so set a property with < via cdata for reuse later -->
  <property name="lt"><![CDATA[<]]></property>


  <macrodef name="installPackage" description="Installs the given managed package">
      <attribute name="namespace" description="Namespace of managed package to install."/>
      <attribute name="version" description="Version of managed package to install."/>
      <attribute name="packagePassword" description="Password used to install the pacakge. Optional." default=""/>
      <attribute name="username" description="Salesforce user name."/>
      <attribute name="password" description="Salesforce password."/>
      <sequential>
          <!-- Generate optional <password> element? -->
          <if><equals arg1="@{packagePassword}" arg2=""/>
              <then><property name="passwordElement" value=""/></then>
              <else><property name="passwordElement" value="&lt;password&gt;@{packagePassword}&lt;/password&gt;"/></else>
          </if>
          <!-- Generate working folder and metadata files representing the package to install -->
          <delete dir="${basedir}/installdeploy"/>
          <mkdir dir="${basedir}/installdeploy"/>
          <mkdir dir="${basedir}/installdeploy"/>         
          <mkdir dir="${basedir}/installdeploy/installedPackages"/>
          <echo file="${basedir}/installdeploy/package.xml"><![CDATA[<Package xmlns="http://soap.sforce.com/2006/04/metadata"><types><members>@{namespace}</members><name>InstalledPackage</name></types><version>${cumulusci.package.apiVersion}</version></Package>]]></echo>
          <echo file="${basedir}/installdeploy/installedPackages/@{namespace}.installedPackage"><![CDATA[<InstalledPackage xmlns="http://soap.sforce.com/2006/04/metadata"><versionNumber>@{version}</versionNumber>${passwordElement}</InstalledPackage>]]></echo>
          <sf:deploy deployRoot="${basedir}/installdeploy" username="@{username}" password="@{password}" maxPoll="500" />
          <delete dir="${basedir}/installdeploy"/>
      </sequential>
  </macrodef>


  <macrodef name="uninstallPackage" description="Uninstalls the given managed package">
      <attribute name="namespace" description="Namespace of managed package to install."/>
      <attribute name="username" description="Salesforce user name."/>
      <attribute name="password" description="Salesforce password."/>
      <sequential>
          <!-- Generate working folder and metadata files representing the package to uninstall -->       
          <delete dir="${basedir}/installdeploy"/>
          <mkdir dir="${basedir}/installdeploy"/>
          <mkdir dir="${basedir}/installdeploy"/>         
          <mkdir dir="${basedir}/installdeploy/installedPackages"/>
          <echo file="${basedir}/installdeploy/package.xml"><![CDATA[<Package xmlns="http://soap.sforce.com/2006/04/metadata"><version>${cumulusci.package.apiVersion}</version></Package>]]></echo>
          <echo file="${basedir}/installdeploy/destructiveChanges.xml"><![CDATA[<Package xmlns="http://soap.sforce.com/2006/04/metadata"><types><members>@{namespace}</members><name>InstalledPackage</name></types><version>${cumulusci.package.apiVersion}</version></Package>]]></echo>
          <echo file="${basedir}/installdeploy/installedPackages/@{namespace}.installedPackage"><![CDATA[<InstalledPackage xmlns="http://soap.sforce.com/2006/04/metadata"><versionNumber>@{version}</versionNumber></InstalledPackage>]]></echo>
          <sf:deploy deployRoot="${basedir}/installdeploy" username="@{username}" password="@{password}" maxPoll="500" />
      </sequential>
  </macrodef>


  <macrodef name="getPackageVersion" description="Sets the InstalledPackage.NAMESPACE.versionNumber property to the version number of the package">
    <attribute name="namespace" description="Package's name to fetch version number for" />
    <attribute name="refresh" default="true" description="Should installedPackages be refreshed from the target org and deleted at the end of execution?" />
    <sequential>
      <!-- If we should refresh the installed packages, refresh them -->
      <if><istrue value="@{refresh}" />
        <then>
          <sf:bulkRetrieve
            username="${sf.username}"
            password="${sf.password}"
            metadataType="InstalledPackage"
            retrieveTarget="${basedir}/installedPackages"/>
        </then>
      </if>

      <if>
        <available file="${basedir}/installedPackages/installedPackages/@{namespace}.installedPackage" />
        <then>
          <!-- replace the string versionNumber with @{namespace}.versionNumber so the property is namespaced when loaded -->
          <replace file="${basedir}/installedPackages/installedPackages/@{namespace}.installedPackage" token="versionNumber" value="@{namespace}.versionNumber" />

          <!-- load the installedPackage file as properties -->
          <xmlproperty file="${basedir}/installedPackages/installedPackages/@{namespace}.installedPackage" />
        </then>
        <else>
          <!-- The package does not exist in the target org -->
          <property name="InstalledPackage.@{namespace}.versionNumber" value="Not Installed" />
        </else>
      </if>

      <!-- If refresh is true, delete the directory created to fetch the installedPackage metadata since it was created in the context of this macro execution-->
      <if>
        <istrue value="@{refresh}"/>
        <then>
          <delete dir="${basedir}/installedPackages"/>
        </then>
      </if>

    </sequential>
  </macrodef>

  <macrodef name="updatePackageVersion" description="Installs a specific version of a package.  If the package needs to be downgraded, first uninstalls the package.">
    <attribute name="namespace" description="Package's name to be installed" />
    <attribute name="version" description="The version to install (ex. 1.3).  Passing Not Installed will ensure the package is uninstalled" />
    <sequential>
      <if>
        <!-- NOTE: This assumes getPackageVersions was already run -->
        <not><equals arg1="${InstalledPackage.@{namespace}.versionNumber}" arg2="@{version}" /></not>
        <then>
          <!-- decide if uninstall is needed -->
          <if>
            <and>
              <!-- package is installed in org -->
              <not><equals arg1="${InstalledPackage.@{namespace}.versionNumber}" arg2="Not Installed" /></not>
            
              <!-- package needs downgrade or should be Not Installed -->
              <or>
                <bool><isgreaterthan arg1="${InstalledPackage.@{namespace}.versionNumber}" arg2="@{version}" /></bool>
                <equals arg1="@{version}" arg2="Not Installed" />
              </or>
            </and>
            <then>
              <echo>Uninstalling @{namespace} ${InstalledPackage.@{namespace}.versionNumber} to downgrade to @{version}</echo>
              <uninstallPackage namespace="@{namespace}" username="${sf.username}" password="${sf.password}"/>
            </then>
            <else>
              <!-- just an upgrade, no need to uninstall first -->
              <echo>Upgrading @{namespace} from ${InstalledPackage.@{namespace}.versionNumber} to @{version}</echo>
            </else>
          </if>
          <if>
            <not><equals arg1="@{version}" arg2="Not Installed" /></not>
            <then>
              <installPackage namespace="@{namespace}" version="@{version}" username="${sf.username}" password="${sf.password}"/>
            </then>
          </if>
        </then>
      </if>
    </sequential>
  </macrodef>

  <macrodef name="retrieveUnpackaged" description="Retrieves all unpackaged metadata from the target org into the specified dir">
    <attribute name="dir" description="The local directory to store the metadata files" />
    <sequential>

      <!-- Create a clean output directory structure -->
      <delete dir="@{dir}" />
      <mkdir dir="@{dir}"/>
      <mkdir dir="@{dir}/unpackaged"/>
      <mkdir dir="@{dir}/standard"/>

      <!-- Retrieve standard objects (uses lib/standard_objects.xml as the manifest) -->
      <sf:retrieve 
        username="${sf.username}" 
        password="${sf.password}" 
        serverurl="${sf.serverurl}" 
        retrieveTarget="@{dir}/standard" 
        unpackaged="lib/standard_objects.xml"/>

      <!-- Retrieve unpackaged metadata (uses lib/all_metadata_types.xml as the manifest) -->
      <sf:retrieve 
        username="${sf.username}" 
        password="${sf.password}" 
        serverurl="${sf.serverurl}" 
        retrieveTarget="@{dir}/unpackaged" 
        unpackaged="lib/all_meta_types.xml"/>

    </sequential>
  </macrodef>

  <macrodef name="deleteWhitelistedMetadata" description="Deletes any metadata files from a given directory which are listed in lib/whitelists/metadata.txt">
    <attribute name="dir" description="The directory to delete metadata from" />
    <sequential>
      <!-- Delete whitelisted files which are added to the org by Salesforce.  This includes both components which are always in an org and components which are automatically created by enabling Sites -->
      <for param="filename" list="${metadata_whitelist}" delimiter="${line.separator}" >
        <sequential>
          <echo>Deleting whitelisted metadata file @{filename}</echo>
          <delete>
            <fileset dir="@{dir}" includes="**/*/@{filename}" />
          </delete>
        </sequential>
      </for>
    </sequential>
  </macrodef>

  <macrodef name="retrievePackaged" description="Retrieves all metadata from a given package into the specified dir">
    <attribute name="package" description="The package name" />
    <attribute name="dir" description="The local directory to store the metadata files" />
    <sequential>
      <delete dir="@{dir}" />
      <mkdir dir="@{dir}"/>
      <sf:retrieve 
        username="${sf.username}" 
        password="${sf.password}" 
        serverurl="${sf.serverurl}" 
        retrieveTarget="@{dir}" 
        packageNames="@{package}"/>
    </sequential>
  </macrodef>

  <macrodef name="buildPackageXmlFromDir" description="Runs through a directory of metadata and builds a package.xml format file from the contents">
    <attribute name="dir" description="The directory containing metadata (i.e. package src)" />
    <attribute name="xmlfile" description="The output file path" />
    <attribute name="version" description="The value for the version element of the package.xml file to set the api version (i.e. ${cumulusci.package.apiVersion})" />
    <attribute name="package" description="If provided, a fullName element will be added to the file so it is deployed into a Package in the target org" default="NOTSET" />
    <attribute name="exclude" description="If provided, a list of filenames to skip." default="" />
  	<attribute name="installClass" description="If provided, a installClass element will be added to the file to specify a class to run when installing the package." default="NOTSET" />
  	<attribute name="uninstallClass" description="If provided, a uninstallClass element will be added to the file to specify a class to run when uninstalling the package." default="NOTSET" />
    <sequential>
      <!-- Write the header for the destructiveChanges.xml -->
      <echo file="@{xmlfile}">&lt;?xml version="1.0" encoding="UTF-8"?&gt;${line.separator}</echo>
      <echo file="@{xmlfile}" append="true">&lt;Package xmlns="http://soap.sforce.com/2006/04/metadata"&gt;${line.separator}</echo>  

      <!-- Loop through the subfolders to add lines to destructiveChanges.xml -->
      <for param="typedir">
        <path>
          <dirset dir="@{dir}" includes="**/*" />
        </path>
        <sequential>
          <basename property="metatype" file="@{typedir}" />

          <!-- Map dir name to a metadata type name.  This also serves as a whitelist for which metadata types to add.  If a mapping is not listed, the type is not added to the package.xml -->
          <!-- FIXME: Is there a cleaner way to do this so the mapping could live in a separate file? -->
          <var name="typename" unset="true" /> 
          <switch value="${metatype}">
            <case value="applications">
              <property name="typename" value="CustomApplication" />
            </case>
            <case value="classes">
              <property name="typename" value="ApexClass" />
            </case>
            <case value="components">
              <property name="typename" value="ApexComponent" />
            </case>
            <case value="labels">
              <property name="typename" value="CustomLabel" />
            </case>
            <case value="layouts">
              <property name="typename" value="Layout" />
            </case>
            <case value="objects">
              <property name="typename" value="CustomObject" />
            </case>
            <case value="pages">
              <property name="typename" value="ApexPage" />
            </case>
            <case value="quickActions">
              <property name="typename" value="QuickAction" />
            </case>
            <case value="remoteSiteSettings">
              <property name="typename" value="RemoteSiteSetting" />
            </case>
            <case value="staticresources">
              <property name="typename" value="StaticResource" />
            </case>
            <case value="tabs">
              <property name="typename" value="CustomTab" />
            </case>
            <case value="triggers">
              <property name="typename" value="ApexTrigger" />
            </case>
            <default/>
          </switch>

          <if>
            <isset property="typename" />
            <then>

              <!-- Write a new <types/> section for the meta type -->
              <echo file="@{xmlfile}" append="true">  &lt;types&gt;${line.separator}</echo>

              <!-- Loop through files in the type's dir and add <members /> element for each file -->
              <for param="file">
                <path>
                  <!-- exclude xml files and namespaced metadata files as well as any manual excludes -->
                  <fileset dir="@{typedir}" includes="**/*" excludes="*.xml *__*__c.object @{exclude}" />
                </path>
                <sequential>
                  <!-- get basename and basename without suffix for file. propertyregex is used since we don't know the file suffix from only the dir name (i.e. classes vs .class) -->
                  <basename property="component_file" file="@{file}" />
                  <propertyregex property="component" input="${component_file}" regexp="(.*)\.(.*)" select="\1" />

                  <!-- If the file is not in the exclude list, add it to the package.xml -->
                  <if>
                    <not><contains string="@{exclude}" substring="${component_file}" /></not>
                    <then>
                      <!-- Write the <members/> element -->
                      <echo file="@{xmlfile}" append="true">    &lt;members&gt;${component}&lt;/members&gt;${line.separator}</echo>
    
                    </then>
                  </if>

                  <!-- Unset basename properties for next execution since we're using basename and propertyregex which will not overwrite a property -->
                  <var name="component" unset="true" />
                  <var name="component_file" unset="true" />
                </sequential>
              </for>

              <!-- Write the <name/> element and close the <types/> element -->
              <echo file="@{xmlfile}" append="true">    &lt;name&gt;${typename}&lt;/name&gt;${line.separator}</echo>
              <echo file="@{xmlfile}" append="true">  &lt;/types&gt;${line.separator}</echo>

            </then>
            <else>
              <echo>Skipping unmapped metadata type ${metatype}</echo>
            </else>
          </if>

          <!-- Unset the metatype so basename can set it on next iteration through loop -->
          <var name="metatype" unset="true" />
        </sequential>
      </for>

      <!-- Write the install and uninstall scripts -->
      <if>
      	<not><equals arg1="@{installClass}" arg2="NOTSET" /></not>
      	<then>
      	    <echo file="@{xmlfile}" append="true">  &lt;postInstallClass&gt;@{installClass}&lt;/postInstallClass&gt;${line.separator}</echo>
        </then>
      </if>
    	
      <if>
        <not><equals arg1="@{uninstallClass}" arg2="NOTSET" /></not>
        <then>
            <echo file="@{xmlfile}" append="true">  &lt;uninstallClass&gt;@{uninstallClass}&lt;/uninstallClass&gt;${line.separator}</echo>
        </then>
      </if>
      <!-- If package is provided, add the fullName element -->
      <if>
        <not><equals arg1="@{package}" arg2="NOTSET" /></not>
        <then>
          <echo file="@{xmlfile}" append="true">  &lt;fullName&gt;@{package}&lt;/fullName&gt;${line.separator}</echo>
        </then>
      </if>

      <!-- Write the <version/> tag and close <Package/> -->
      <echo file="@{xmlfile}" append="true">  &lt;version&gt;@{version}&lt;/version&gt;${line.separator}</echo>
      <echo file="@{xmlfile}" append="true">&lt;/Package&gt;</echo>
    </sequential>
  </macrodef>

  <macrodef name="getWhitelistForObjectAndType" description="Given an object and a type, returns the whitelist for the type if set">
    <attribute name="object" description="The Salesforce api name of the object" />
    <attribute name="type" description="The metadata type name (i.e. CustomField)" />
    <attribute name="property" description="The name of the property to populate with the whitelist" />
    <sequential>
      <!-- this is split out into a separate macro so we can use a dynamic property name to lookup the whitelist -->
      <if>
        <isset property="@{property}" />
        <then>
          <var name="@{property}" unset="true" />
        </then>
      </if>
      <property name="@{property}" value="${whitelist.@{object}.@{type}}" />
    </sequential>
  </macrodef>

  <macrodef name="addMetadataSubType" description="Uses an xsl template to parse out metadata subtypes from a parent file and adds to a package.xml file">
    <attribute name="dir" description="The package directory containing the files to search in." />
    <attribute name="suffix" description="The suffix of the metadata file to search in.  For example, object for object files" default="object" />
    <attribute name="xmlfile" description="The path of the target package.xml or destructiveChanges.xml file" />
    <attribute name="typename" description="The type name as would appear in the manifest type's name element" />
    <attribute name="xslt" description="The path of the xslt transform to extract type components from the standard object file" default="lib/extract_subtype.xsl" />
    <attribute name="element" description="The xml element to look for.  This is passed to the xslt to allow easier template reuse" />
    <attribute name="nameelement" description="The xml element whose value should provide the name (used in the package.xml members tag)." default="fullName" />
    <attribute name="parentelement" description="The containing element name in target files.  For example, CustomObject if looking in object files" default="CustomObject" />
    <sequential>
      <!-- Make sure the directory actually exist, otherwise do nothing -->
      <if>
        <available file="@{dir}" type="dir" />
        <then>
          <!-- First, build a FILE.SUFFIX.typename file containing the <members/> elements for all components of the type -->
          <for param="file">
            <path>
              <fileset dir="@{dir}" includes="*.@{suffix}" />
            </path>
            <sequential>
              <!-- Parse the file basename and parent name from the parent's filename -->
              <basename property="parent_file" file="@{file}" />
              <basename property="parent" file="@{file}" suffix=".@{suffix}" />

              <!-- Construct an xslt file from the template by replacing ___element with @{element}.  
                   This is to get around xslt's limitations in selecting an element whose name is passed as a parameter.
                   This approach avoids the need to create an xsl file for each metadata subtype
                -->
              <copy file="@{xslt}" tofile="@{xslt}.rendered" />
              <replaceregexp file="@{xslt}.rendered" match="___parentelement___" replace="@{parentelement}" flags="g" />
              <replaceregexp file="@{xslt}.rendered" match="___element___" replace="@{element}" flags="g" />
              <replaceregexp file="@{xslt}.rendered" match="___nameelement___" replace="@{nameelement}" flags="g" />

              <!-- Run xslt to build a file for each parent containing <members/> elements for components -->
              <getWhitelistForObjectAndType object="${parent}" type="@{typename}" property="obj_type_whitelist" />
              <xslt in="@{file}" out="@{dir}/${parent_file}.@{typename}" style="@{xslt}.rendered">
                <param name="whitelist" expression="${obj_type_whitelist}" />
              </xslt>
              <delete file="@{xslt}.rendered" />

              <!-- Prepend member names with OBJECT. -->
              <if>
                <equals arg1="@{suffix}" arg2="object" />
                <then>
                  <replaceregexp file="@{dir}/${parent_file}.@{typename}" match="members>(.*)./members>" replace="members>${parent}.\1&lt;/members>${line.separator}" flags="g" />
                </then>
              </if>

              <!-- Unset properites for basename call in next iteration of loop -->
              <var name="parent" unset="true" />
              <var name="parent_file" unset="true" />
            </sequential>
          </for>

          <!-- Concatenate all <members/> from earlier extraction output files -->
          <concat destfile="@{dir}/@{typename}.extract">
            <fileset dir="@{dir}" includes="**/*.@{suffix}.@{typename}" />
            <filterchain>
              <prefixlines prefix="    " />
              <linecontains>
                <contains value="members>" />
              </linecontains>
            </filterchain>
          </concat>

          <!-- If there are any members to extract, add the <types/> section to package.xml -->
          <if>
            <available file="@{dir}/@{typename}.extract" />
            <then>
              <loadfile property="type.extract" srcfile="@{dir}/@{typename}.extract" />
              <if>
                <isset property="type.extract" /> 
                <then>
                  <var name="type.extract" value="${line.separator}  ${lt}types>${line.separator}${type.extract}    ${lt}name>@{typename}${lt}/name>${line.separator}  ${lt}/types>" />
                  <replaceregexp file="@{xmlfile}" match="Package(.*)>" replace="Package\1>${type.extract}" />
                  <xslt in="@{xmlfile}" out="@{xmlfile}.tidy" style="lib/tidy_package_xml.xsl" />
                  <move file="@{xmlfile}.tidy" tofile="@{xmlfile}" />
                </then>
              </if>
              <delete>
                  <fileset dir="@{dir}" includes="**/*.@{typename}" />
              </delete>
              <delete file="@{dir}/@{typename}.extract" />
        
              <var name="type.extract" unset="true" />
            </then>  
          </if>
        </then>
      </if>
    </sequential>  
  </macrodef>

  <macrodef name="buildPackageXml" description="Construct a complete package.xml file based on the metadata in the src directory">
    <attribute name="version" description="The value for the version element in the package.xml" />
    <attribute name="package" description="The value for the fullName element in the package.xml" default="NOTSET" />
    <attribute name="installClass" description="If provided, a installClass element will be added to the file to specify a class to run when installing the package." default="NOTSET" />
    <attribute name="uninstallClass" description="If provided, a uninstallClass element will be added to the file to specify a class to run when uninstalling the package." default="NOTSET" />
  
    <sequential>
      <!-- Exclude CustomLabels.labels so we can use addMetadataSubType on it instead -->
      <buildPackageXmlFromDir dir="${basedir}/src" xmlfile="${basedir}/src/package.xml.new" package="@{package}" version="@{version}" exclude="CustomLabels.labels" installClass="@{installClass}" uninstallClass="@{uninstallClass}" />

      <!-- Add metadata sub-types of object which need to be explicitly listed in package.xml -->
      <!--<addMetadataSubType dir="${basedir}/src" xmlfile="${basedir}/src/package.xml.new" typename="ActionOverride" element="actionOverrides" nameelement="actionName" />-->
      <addMetadataSubType dir="${basedir}/src/objects" xmlfile="${basedir}/src/package.xml.new" typename="BusinessProcess" element="businessProcesses" />
      <addMetadataSubType dir="${basedir}/src/objects" xmlfile="${basedir}/src/package.xml.new" typename="CompactLayout" element="compactLayouts" />
      <addMetadataSubType dir="${basedir}/src/objects" xmlfile="${basedir}/src/package.xml.new" typename="CustomField" element="fields" xslt="lib/extract_obj_fields.xsl" />
      <addMetadataSubType dir="${basedir}/src/labels" suffix="labels" xmlfile="${basedir}/src/package.xml.new" typename="CustomLabel" element="labels" parentelement="CustomLabels" />
      <addMetadataSubType dir="${basedir}/src/objects" xmlfile="${basedir}/src/package.xml.new" typename="FieldSet" element="fieldSets" />
      <addMetadataSubType dir="${basedir}/src/objects" xmlfile="${basedir}/src/package.xml.new" typename="ListView" element="listViews" />
      <addMetadataSubType dir="${basedir}/src/objects" xmlfile="${basedir}/src/package.xml.new" typename="NamedFilter" element="namedFilters" />
      <addMetadataSubType dir="${basedir}/src/objects" xmlfile="${basedir}/src/package.xml.new" typename="RecordType" element="recordTypes" />
      <addMetadataSubType dir="${basedir}/src/objects" xmlfile="${basedir}/src/package.xml.new" typename="WebLink" element="webLinks" />

      <move file="${basedir}/src/package.xml.new" tofile="${basedir}/src/package.xml" />
    </sequential>
  </macrodef>

  <macrodef name="buildDestroyStaleMetadata" description="Constructs a destructiveChanges.xml which deletes any metadata from one directory which does not exist in another">
    <attribute name="srcdir" description="Source directory, usually containing metadata from target org fetched via retrievePackaged" />
    <attribute name="commdir" description="The directory whose metadata should be compared to srcdir.  Any metadata not in this directory's package.xml but in srcdir's package.xml will be added to destructiveChanges.xml" />
    <attribute name="dir" description="Target directory to create the destructiveChanges.xml package" />
    <sequential>
      <!-- Run xslt against package.xml files to generate a text file containing TYPE::MEMBER lines for each member for easier comparison later -->
      <xslt in="@{srcdir}/package.xml" out="@{srcdir}/package.xml.members" style="lib/diff_package_xml.xsl" />
      <xslt in="@{commdir}/package.xml" out="@{commdir}/package.xml.members" style="lib/diff_package_xml.xsl" />
      <loadfile property="src.package.xml.members" srcfile="@{srcdir}/package.xml.members" />
      <loadfile property="comm.package.xml.members" srcfile="@{commdir}/package.xml.members" />

      <delete dir="@{dir}" />
      <mkdir dir="@{dir}" />

      <!-- Create the package.xml to accompany the destructiveChanges.xml -->
      <echo file="@{dir}/package.xml"><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<Package xmlns="http://soap.sforce.com/2006/04/metadata">
<version>${cumulusci.package.apiVersion}</version>
</Package>]]></echo>

      <!-- initialize the destructiveChanges.xml file -->
      <echo file="@{dir}/destructiveChanges.xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;${line.separator}</echo>
      <echo file="@{dir}/destructiveChanges.xml" append="true">&lt;Package xmlns="http://soap.sforce.com/2006/04/metadata"&gt;${line.separator}</echo>

      <var name="dest.types.xml" value="" />
      <var name="prev.type" value="" />

      <for delimiter="${line.separator}" list="${src.package.xml.members}" param="line" trim="true">
        <sequential>
          <if>
            <!-- Only process lines which contain ::, the delimiter added by the xslt template between type and member name -->
            <contains string="@{line}" substring="::" />
            <then>
              <if>
                <and>
                  <not><contains string="${comm.package.xml.members}" substring="@{line}" /></not>
                  <!-- Skip CustomLabels since individual custom labels are deleted via CustomLabel -->
                  <not><contains string="@{line}" substring="CustomLabels::" /></not>
                </and>
                <then>
                  <!-- Parse type and member name from string in format TYPE::MEMBERNAME -->
                  <propertyregex property="line.type" override="true" input="@{line}" regexp="(.*)\::(.*)" replace="\1" />
                  <propertyregex property="line.member" override="true" input="@{line}" regexp="(.*)\::(.*)" replace="\2" />
                  <if>
                    <not><equals arg1="${prev.type}" arg2="" /></not>
                    <then>
                      <if>
                        <not><equals arg1="${prev.type}" arg2="${line.type}" /></not>
                        <then>
                          <var name="dest.types.xml" value="${dest.types.xml}    &lt;name>${prev.type}&lt;/name>${line.separator}  &lt;/types>${line.separator}  &lt;types>${line.separator}" />
                          <var name="prev.type" value="${line.type}" />
                        </then>
                        <else>
                        </else>
                      </if>
                    </then>
                    <else>
                      <var name="dest.types.xml" value="${dest.types.xml}  &lt;types>${line.separator}" />
                      <var name="prev.type" value="${line.type}" />
                    </else>
                  </if>
                  <var name="dest.types.xml" value="${dest.types.xml}    &lt;members>${line.member}&lt;/members>${line.separator}" />
                </then>
              </if>
            </then>
          </if>
        </sequential>
      </for>
      <if>
        <not><equals arg1="${prev.type}" arg2="" /></not>
        <then>
          <var name="dest.types.xml" value="${dest.types.xml}    &lt;name>${line.type}&lt;/name>${line.separator}  &lt;/types>${line.separator}" />
        </then>
      </if>

      <!-- Finalize the destructiveChanges.xml file -->
      <echo file="@{dir}/destructiveChanges.xml" append="true">${dest.types.xml}</echo>
      <echo file="@{dir}/destructiveChanges.xml" append="true">  &lt;version&gt;${cumulusci.package.apiVersion}&lt;/version&gt;${line.separator}</echo>
      <echo file="@{dir}/destructiveChanges.xml" append="true">&lt;/Package&gt;</echo>

      <!-- clean up -->
      <delete file="@{srcdir}/package.xml.members" />
      <delete file="@{commdir}/package.xml.members" />
    </sequential>
  </macrodef>

  <macrodef name="buildPackagedDestructiveChanges" description="Constructs a destructiveChanges.xml file which deletes all metadata from a package">
    <attribute name="package" description="The package name" />
    <attribute name="srcdir" description="Source directory containing the retrieved standard object and unpackaged metadata for the org.  This directory should be created by retrieveUnpackaged" />
    <attribute name="dir" description="Target directory to create the standard and unpackaged packages for undeployment" />
    <sequential>

      <!-- Create a clean directory structure to work with -->
      <delete dir="@{dir}" />
      <mkdir dir="@{dir}" />

      <property name="destxml" value="@{dir}/destructiveChanges.xml" />

      <!-- Create the package.xml to accompany the destructiveChanges.xml -->
      <echo file="@{dir}/package.xml"><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<Package xmlns="http://soap.sforce.com/2006/04/metadata">
<version>${cumulusci.package.apiVersion}</version>
</Package>]]></echo>

      <!-- Add the package name to the package.xml file -->
      <replaceregexp file="@{xmlfile}" match="Package(.*)>" replace="Package\1>&lt;fullName>@{package}%lt;/fullName>${line-separator}" />

      <!-- Build the destructiveChanges.xml file by walking the srcdir and adding all metadata -->
      <!-- Exclude CustomLabels.labels so we can use addMetadataSubType on it instead -->
      <buildPackageXmlFromDir dir="@{srcdir}" xmlfile="@{dir}/destructiveChanges.xml" version="${cumulusci.package.apiVersion}" exclude="${metadata_whitelist} CustomLabels.labels" />

      <!-- Add standard object fields to destructiveChanges.xml -->
      <addMetadataSubType dir="@{srcdir}/objects" xmlfile="@{dir}/destructiveChanges.xml" typename="CompactLayout" element="compactLayouts" />
      <addMetadataSubType dir="@{srcdir}/objects" xmlfile="@{dir}/destructiveChanges.xml" typename="CustomField" element="fields" xslt="lib/extract_obj_fields.xsl" />
      <addMetadataSubType dir="@{srcdir}/labels" suffix="labels" xmlfile="@{dir}/destructiveChanges.xml" typename="CustomLabel" element="labels" parentelement="CustomLabels" />
      <addMetadataSubType dir="@{srcdir}/objects" xmlfile="@{dir}/destructiveChanges.xml" typename="FieldSet" element="fieldSets" />
      <addMetadataSubType dir="@{srcdir}/objects" xmlfile="@{dir}/destructiveChanges.xml" typename="ListView" element="listViews" />
      <addMetadataSubType dir="@{srcdir}/objects" xmlfile="@{dir}/destructiveChanges.xml" typename="NamedFilter" element="namedFilters" />
      <!--<addMetadataSubType dir="@{srcdir}" xmlfile="@{dir}/destructiveChanges.xml" typename="RecordType" element="recordTypes" />-->
      <addMetadataSubType dir="@{srcdir}/objects" xmlfile="@{dir}/destructiveChanges.xml" typename="WebLink" element="webLinks" />

    </sequential>
  </macrodef>

  <macrodef name="buildUnpackagedDestructiveChanges" description="Construct two packages.  The first package resets standard object ActionOverrides to type Default.  The second uses a custom built destructiveChanges.xml file to delete all unpackaged metadata">
    <attribute name="srcdir" description="Source directory containing the retrieved standard object and unpackaged metadata for the org.  This directory should be created by retrieveUnpackaged" />
    <attribute name="dir" description="Target directory to create the standard and unpackaged packages for undeployment" />
    <sequential>

      <!-- Create a clean directory structure to work with -->
      <delete dir="@{dir}" />
      <mkdir dir="@{dir}" />
      <mkdir dir="@{dir}/standard" />
      <mkdir dir="@{dir}/unpackaged" />

      <!-- Create the package.xml to accompany the destructiveChanges.xml -->
      <echo file="@{dir}/unpackaged/package.xml"><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<Package xmlns="http://soap.sforce.com/2006/04/metadata">
<version>${cumulusci.package.apiVersion}</version>
</Package>]]></echo>

      <!-- Build the destructiveChanges.xml file by walking the unpackaged directory and adding all metadata -->
      <!-- Exclude CustomLabels.labels so we can use addMetadataSubType on it instead -->
      <buildPackageXmlFromDir dir="@{srcdir}/unpackaged" xmlfile="@{dir}/unpackaged/destructiveChanges.xml" version="${cumulusci.package.apiVersion}" exclude="CustomLabels.labels" />
     
      <!-- Copy the package manifest used to retrieve standard objects into srcdir and create an objects subfolder-->
      <copy file="@{srcdir}/standard/package.xml" todir="@{dir}/standard" />
      <mkdir dir="@{dir}/standard/objects" />

      <!-- Built a reset version of each retrieved standard object and add sub metadata types of object to destructiveChanges.xml -->
      <for param="file">
        <path>
          <fileset dir="@{srcdir}/standard/objects" includes="**/*.object" />
        </path>
        <sequential>
          <!-- Parse the file basename and object name from the object's filename -->
          <basename property="obj_file" file="@{file}" />
          <basename property="object" file="@{file}" suffix=".object" />

          <!-- Rewrite all ActionOverrides to type Default.  This is a special case since we can't delete ActionOverrides via destructiveChanges.xml -->
          <xslt in="@{file}" out="@{dir}/standard/objects/${obj_file}" style="lib/remove_action_overrides.xsl" />

          <!-- Unset properites for basename call in next iteration of loop -->
          <var name="object" unset="true" />
          <var name="obj_file" unset="true" />
        </sequential>
      </for>

      <!-- Add sub metadata types which can be deleted to destructiveChanges.xml.  Currently this only handles custom fields and fieldsets. -->

      <addMetadataSubType dir="@{srcdir}/standard/objects" xmlfile="@{dir}/unpackaged/destructiveChanges.xml" typename="CompactLayout" element="compactLayout" />
      <addMetadataSubType dir="@{srcdir}/standard/objects" xmlfile="@{dir}/unpackaged/destructiveChanges.xml" typename="CustomField" element="fields" xslt="lib/extract_obj_fields.xsl" />
      <addMetadataSubType dir="@{srcdir}/unpackaged/labels" suffix="labels" xmlfile="@{dir}/unpackaged/destructiveChanges.xml" typename="CustomLabel" element="labels" parentelement="CustomLabels" />
      <addMetadataSubType dir="@{srcdir}/standard/objects" xmlfile="@{dir}/unpackaged/destructiveChanges.xml" typename="FieldSet" element="fieldSets" />
      <addMetadataSubType dir="@{srcdir}/standard/objects" xmlfile="@{dir}/unpackaged/destructiveChanges.xml" typename="ListView" element="listViews" />
      <addMetadataSubType dir="@{srcdir}/standard/objects" xmlfile="@{dir}/unpackaged/destructiveChanges.xml" typename="NamedFilter" element="namedFilters" />
      <!--<addMetadataSubType dir="@{srcdir}/standard" xmlfile="@{dir}/unpackaged/destructiveChanges.xml" typename="RecordType" element="recordTypes" />-->
      <addMetadataSubType dir="@{srcdir}/standard/objects" xmlfile="@{dir}/unpackaged/destructiveChanges.xml" typename="WebLink" element="webLinks" />

    </sequential>

  </macrodef>

  <macrodef name="updateMetaXml" description="Updates all references to a given namespace in *-meta.xml files to a specific version">
    <attribute name="dir" description="The package directory containing the *-meta.xml files to update" />
    <attribute name="namespace" description="The namespace (i.e. npe01)" />
    <attribute name="version" description="The version number (i.e. 2.1)" />
    <sequential>

      <delete file="lib/update_meta_xml.xsl.rendered" />
      <copy file="lib/update_meta_xml.xsl" tofile="lib/update_meta_xml.xsl.rendered" />
      <replaceregexp file="lib/update_meta_xml.xsl.rendered" match="___namespace___" replace="@{namespace}" flags="g" />

      <propertyregex property="updatemetaxml.major" override="true" input="${version.@{namespace}}" regexp="(\d+)\.(\d+)" replace="\1" />
      <propertyregex property="updatemetaxml.minor" override="true" input="${version.@{namespace}}" regexp="(\d+)\.(\d+)" replace="\2" />

      <for param="file">
        <path>
          <fileset dir="@{dir}" includes="**/*-meta.xml" />
        </path>
        <sequential>
          <xslt in="@{file}" out="@{file}.updated" style="lib/update_meta_xml.xsl.rendered">
            <param name="major" expression="${updatemetaxml.major}" />
            <param name="minor" expression="${updatemetaxml.minor}" />
          </xslt>
          <if>
            <not><filesmatch file1="@{file}" file2="@{file}.updated" /></not>
            <then>
              <echo>@{file} updated for @{namespace}</echo>
              <move file="@{file}.updated" tofile="@{file}" />
            </then>
          </if>
          <delete file="@{file}.updated" />
        </sequential>
      </for>
      <delete file="lib/update_meta_xml.xsl.rendered" />
    </sequential>
  </macrodef>

  <macrodef name="updateMetaXmlApi" description="Updates all apiVersion elements in all *-meta.xml files in target directory">
    <attribute name="dir" description="The package directory containing the *-meta.xml files to update" />
    <attribute name="apiVersion" description="The apiVersion value (i.e. 31.0)" />
    <sequential>

      <for param="file">
        <path>
          <fileset dir="@{dir}" includes="**/*-meta.xml" />
        </path>
        <sequential>
          <xslt in="@{file}" out="@{file}.updated" style="lib/update_meta_xml_api.xsl">
            <param name="apiVersion" expression="@{apiVersion}" />
          </xslt>
          <if>
            <not><filesmatch file1="@{file}" file2="@{file}.updated" /></not>
            <then>
              <echo>@{file} updated for @{namespace}</echo>
              <move file="@{file}.updated" tofile="@{file}" />
            </then>
          </if>
          <delete file="@{file}.updated" />
        </sequential>
      </for>
    </sequential>
  </macrodef>

  <macrodef name="deployMetadataBundles" description="Deploys all subfolders of a given dir as individual metadata bundles replacing %%%NAMESPACE%%% with either blank or a namespace prefix in all files">
    <attribute name="dir" description="The parent directory containing subfolders each representing an individual metadata bundle" />
    <attribute name="stagedir" description="The directory where rendered bundles should be staged for deployment.  This directory is created and deleted by the macro" />
    <attribute name="nsprefix" description="The string to replace all instances of %%%NAMESPACE%%% in the source files" default="" />
    
    <sequential>
      <if>
        <available file="@{dir}" type="dir" />
        <then>
          <for param="subdir">
            <path>
              <dirset dir="@{dir}/" includes="*" />
            </path>
            <sequential>
              <echo>Injecting namespace prefix "@{namespace_prefix}" into bundle @{subdir}</echo>

              <!-- Copy the bundle to the staging directory so we can do the replacement there without affecting the original source files -->
              <delete dir="@{stagedir}" />
              <copy todir="@{stagedir}">
                <fileset dir="@{subdir}"/>
              </copy>
              <replaceNamespacePrefix dir="@{stagedir}" nsprefix="@{nsprefix}" />
                
              <echo>Deploying unpackaged bundle @{subdir}</echo>
              <sf:deploy username="${sf.username}" password="${sf.password}" serverurl="${sf.serverurl}" deployRoot="@{stagedir}" runAllTests="false" maxPoll="${cumulusci.maxPoll.notest}" />
            </sequential>
          </for>
        </then>
      </if>
    </sequential>
  </macrodef>

  <macrodef name="zipMetadataBundles" description="Zips all subfolders of a given dir as individual metadata bundles replacing %%%NAMESPACE%%% with either blank or a namespace prefix in all files">
    <attribute name="dir" description="The parent directory containing subfolders each representing an individual metadata bundle" />
    <attribute name="stagedir" description="The directory where rendered bundles should be staged for deployment.  This directory is created and deleted by the macro" />
    <attribute name="zipdir" description="The directory where zipped bundles should be stored" />
    <attribute name="nsprefix" description="The string to replace all instances of %%%NAMESPACE%%% in the source files" default="" />

    <sequential>
      <mkdir dir="@{zipdir}" />
      <if>
        <available file="@{dir}" type="dir" />
        <then>
          <for param="subdir">
            <path>
              <dirset dir="@{dir}/" includes="*" />
            </path>
            <sequential>
              <echo>Injecting namespace prefix "@{namespace_prefix}" into bundle @{subdir}</echo>

              <!-- Copy the bundle to the staging directory so we can do the replacement there without affecting the original source files -->
              <delete dir="@{stagedir}" />
              <copy todir="@{stagedir}">
                <fileset dir="@{subdir}"/>
              </copy>
              <replaceNamespacePrefix dir="@{stagedir}" nsprefix="@{nsprefix}" />
            
              <var name="bundle_dirname" unset="true" />
              <var name="bundle_dir" unset="true" />
              <var name="bundle_basename" unset="true" />
              <dirname property="bundle_dirname" file="@{subdir}" />
              <basename property="bundle_dir" file="${bundle_dirname}" />
              <basename property="bundle_basename" file="@{subdir}" />

              <echo>Zipping bundle @{subdir} to @{zipdir}/${bundle_dir}/${bundle_basename}.zip</echo> 
              <mkdir dir="@{zipdir}/${bundle_dir}" />
              <zip destfile="@{zipdir}/${bundle_dir}/${bundle_basename}.zip" basedir="@{stagedir}" />
            </sequential>
          </for>
        </then>
      </if>
    </sequential>
  </macrodef>

  <macrodef name="replaceNamespacePrefix" description="Replaces all instances of the string %%%NAMESPACE%%% with the provided namespace prefix in the target directory">
    <attribute name="dir" description="A directory containing metadata files to inject the namespace into" />
    <attribute name="nsprefix" description="The string to use for the namespace prefix" />
    <sequential>
      <for param="file">
        <path>
          <fileset dir="@{dir}/" includes="**/*" />
        </path>
        <sequential>
          <replaceregexp file="@{file}" match="%%%NAMESPACE%%%" replace="@{nsprefix}" flags="g" />
        </sequential>
      </for>
    </sequential>
  </macrodef>

</project>
